; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -S -loop-reduce < %s | FileCheck %s

;;target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
target triple = "aarch64-unknown-linux-gnu"

define void @mulvl123_addressing(ptr %src, ptr %dst, i64 %count) #0 {
; CHECK-LABEL: define void @mulvl123_addressing(
; CHECK-SAME: ptr [[SRC:%.*]], ptr [[DST:%.*]], i64 [[COUNT:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VSCALE:%.*]] = tail call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[TMP0:%.*]] = shl nuw nsw i64 [[VSCALE]], 4
; CHECK-NEXT:    [[TMP1:%.*]] = mul nuw nsw i64 [[VSCALE]], 80
; CHECK-NEXT:    [[TMP2:%.*]] = mul i64 [[VSCALE]], 48
; CHECK-NEXT:    [[TMP3:%.*]] = shl i64 [[VSCALE]], 5
; CHECK-NEXT:    [[TMP4:%.*]] = shl i64 [[VSCALE]], 4
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi ptr [ [[SCEVGEP:%.*]], [[FOR_BODY]] ], [ [[SRC]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[IDX:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[IDX_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[TMP5:%.*]] = load <vscale x 16 x i8>, ptr [[LSR_IV]], align 16
; CHECK-NEXT:    [[SCEVGEP3:%.*]] = getelementptr i8, ptr [[LSR_IV]], i64 [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = load <vscale x 16 x i8>, ptr [[SCEVGEP3]], align 16
; CHECK-NEXT:    [[SCEVGEP2:%.*]] = getelementptr i8, ptr [[LSR_IV]], i64 [[TMP3]]
; CHECK-NEXT:    [[TMP7:%.*]] = load <vscale x 16 x i8>, ptr [[SCEVGEP2]], align 16
; CHECK-NEXT:    [[SCEVGEP1:%.*]] = getelementptr i8, ptr [[LSR_IV]], i64 [[TMP2]]
; CHECK-NEXT:    [[TMP8:%.*]] = load <vscale x 16 x i8>, ptr [[SCEVGEP1]], align 16
; CHECK-NEXT:    [[TMP9:%.*]] = tail call <vscale x 16 x i8> @llvm.umax.nxv16i8(<vscale x 16 x i8> [[TMP5]], <vscale x 16 x i8> [[TMP6]])
; CHECK-NEXT:    [[TMP10:%.*]] = tail call <vscale x 16 x i8> @llvm.umax.nxv16i8(<vscale x 16 x i8> [[TMP7]], <vscale x 16 x i8> [[TMP8]])
; CHECK-NEXT:    [[TMP11:%.*]] = tail call <vscale x 16 x i8> @llvm.umax.nxv16i8(<vscale x 16 x i8> [[TMP9]], <vscale x 16 x i8> [[TMP10]])
; CHECK-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds i8, ptr [[DST]], i64 [[IDX]]
; CHECK-NEXT:    store <vscale x 16 x i8> [[TMP11]], ptr [[ARRAYIDX4]], align 16
; CHECK-NEXT:    [[IDX_NEXT]] = add i64 [[IDX]], [[TMP0]]
; CHECK-NEXT:    [[SCEVGEP]] = getelementptr i8, ptr [[LSR_IV]], i64 [[TMP1]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i64 [[IDX_NEXT]], [[COUNT]]
; CHECK-NEXT:    br i1 [[CMP]], label [[FOR_BODY]], label [[FOR_EXIT:%.*]]
; CHECK:       for.exit:
; CHECK-NEXT:    ret void
;
entry:
  %vscale = tail call i64 @llvm.vscale.i64()
  %2 = shl nuw nsw i64 %vscale, 4
  %mul = shl nuw nsw i64 %vscale, 6
  br label %for.body

for.body:
  %src.addr = phi ptr [ %src, %entry ], [ %src.addr.next, %for.body ]
  %idx = phi i64 [ 0, %entry ], [ %idx.next, %for.body ]
  %arrayidx = getelementptr inbounds i8, ptr %src.addr, i64 %idx
  %3 = load <vscale x 16 x i8>, ptr %arrayidx
  %4 = getelementptr <vscale x 16 x i8>, ptr %arrayidx, i64 1
  %5 = load <vscale x 16 x i8>, ptr %4
  %6 = getelementptr <vscale x 16 x i8>, ptr %arrayidx, i64 2
  %7 = load <vscale x 16 x i8>, ptr %6
  %8 = getelementptr <vscale x 16 x i8>, ptr %arrayidx, i64 3
  %9 = load <vscale x 16 x i8>, ptr %8
  %10 = tail call <vscale x 16 x i8> @llvm.umax.nxv16i8(<vscale x 16 x i8> %3, <vscale x 16 x i8> %5)
  %11 = tail call <vscale x 16 x i8> @llvm.umax.nxv16i8(<vscale x 16 x i8> %7, <vscale x 16 x i8> %9)
  %12 = tail call <vscale x 16 x i8> @llvm.umax.nxv16i8(<vscale x 16 x i8> %10, <vscale x 16 x i8> %11)
  %src.addr.next = getelementptr inbounds i8, ptr %src.addr, i64 %mul
  %arrayidx4 = getelementptr inbounds i8, ptr %dst, i64 %idx
  store <vscale x 16 x i8> %12, ptr %arrayidx4
  %idx.next = add i64 %idx, %2
  %cmp = icmp ult i64 %idx.next, %count
  br i1 %cmp, label %for.body, label %for.exit

for.exit:
  ret void
}

define void @many_mulvl1_addressing(ptr %src_rows, ptr %dst_rows, i64 %stride, i64 %count) #0 {
; CHECK-LABEL: define void @many_mulvl1_addressing(
; CHECK-SAME: ptr [[SRC_ROWS:%.*]], ptr [[DST_ROWS:%.*]], i64 [[STRIDE:%.*]], i64 [[COUNT:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VSCALE:%.*]] = tail call i64 @llvm.vscale.i64()
; CHECK-NEXT:    [[MUL:%.*]] = shl i64 [[VSCALE]], 5
; CHECK-NEXT:    [[SCEVGEP:%.*]] = getelementptr i8, ptr [[SRC_ROWS]], i64 [[STRIDE]]
; CHECK-NEXT:    [[TMP0:%.*]] = shl i64 [[VSCALE]], 4
; CHECK-NEXT:    [[TMP1:%.*]] = shl i64 [[VSCALE]], 3
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[LSR_IV10:%.*]] = phi i64 [ [[LSR_IV_NEXT11:%.*]], [[FOR_BODY]] ], [ [[COUNT]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[LSR_IV:%.*]] = phi i64 [ [[LSR_IV_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY]] ]
; CHECK-NEXT:    [[SCEVGEP6:%.*]] = getelementptr i8, ptr [[SRC_ROWS]], i64 [[LSR_IV]]
; CHECK-NEXT:    [[SCEVGEP9:%.*]] = getelementptr i8, ptr [[DST_ROWS]], i64 [[LSR_IV]]
; CHECK-NEXT:    [[TMP2:%.*]] = load <vscale x 16 x i8>, ptr [[SCEVGEP6]], align 16
; CHECK-NEXT:    [[SCEVGEP4:%.*]] = getelementptr i8, ptr [[SRC_ROWS]], i64 [[LSR_IV]]
; CHECK-NEXT:    [[SCEVGEP5:%.*]] = getelementptr i8, ptr [[SCEVGEP4]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP3:%.*]] = load <vscale x 16 x i8>, ptr [[SCEVGEP5]], align 16
; CHECK-NEXT:    [[SCEVGEP3:%.*]] = getelementptr i8, ptr [[SCEVGEP]], i64 [[LSR_IV]]
; CHECK-NEXT:    [[TMP4:%.*]] = load <vscale x 16 x i8>, ptr [[SCEVGEP3]], align 16
; CHECK-NEXT:    [[SCEVGEP1:%.*]] = getelementptr i8, ptr [[SCEVGEP]], i64 [[LSR_IV]]
; CHECK-NEXT:    [[SCEVGEP2:%.*]] = getelementptr i8, ptr [[SCEVGEP1]], i64 [[TMP0]]
; CHECK-NEXT:    [[TMP5:%.*]] = load <vscale x 16 x i8>, ptr [[SCEVGEP2]], align 16
; CHECK-NEXT:    [[TMP6:%.*]] = add <vscale x 16 x i8> [[TMP2]], [[TMP4]]
; CHECK-NEXT:    [[TMP7:%.*]] = add <vscale x 16 x i8> [[TMP3]], [[TMP5]]
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast <vscale x 16 x i8> [[TMP6]] to <vscale x 8 x i16>
; CHECK-NEXT:    [[TMP9:%.*]] = trunc <vscale x 8 x i16> [[TMP8]] to <vscale x 8 x i8>
; CHECK-NEXT:    store <vscale x 8 x i8> [[TMP9]], ptr [[SCEVGEP9]], align 8
; CHECK-NEXT:    [[TMP10:%.*]] = bitcast <vscale x 16 x i8> [[TMP7]] to <vscale x 8 x i16>
; CHECK-NEXT:    [[SCEVGEP7:%.*]] = getelementptr i8, ptr [[DST_ROWS]], i64 [[LSR_IV]]
; CHECK-NEXT:    [[SCEVGEP8:%.*]] = getelementptr i8, ptr [[SCEVGEP7]], i64 [[TMP1]]
; CHECK-NEXT:    [[TMP11:%.*]] = trunc <vscale x 8 x i16> [[TMP10]] to <vscale x 8 x i8>
; CHECK-NEXT:    store <vscale x 8 x i8> [[TMP11]], ptr [[SCEVGEP8]], align 8
; CHECK-NEXT:    [[LSR_IV_NEXT]] = add i64 [[LSR_IV]], [[MUL]]
; CHECK-NEXT:    [[LSR_IV_NEXT11]] = add i64 [[LSR_IV10]], -1
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[LSR_IV_NEXT11]], 0
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_EXIT:%.*]], label [[FOR_BODY]]
; CHECK:       for.exit:
; CHECK-NEXT:    ret void
;
entry:
  %vscale = tail call i64 @llvm.vscale.i64()
  %mul = shl nuw nsw i64 %vscale, 5
  br label %for.body

for.body:
  %src_row_addr = phi ptr [ %src_rows, %entry ], [ %add_ptr_src, %for.body ]
  %dst_row_addr = phi ptr [ %dst_rows, %entry ], [ %add_ptr_dst, %for.body ]
  %idx = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %2 = load <vscale x 16 x i8>, ptr %src_row_addr
  %3 = getelementptr <vscale x 16 x i8>, ptr %src_row_addr, i64 1
  %4 = load <vscale x 16 x i8>, ptr %3
  %arrayidx2 = getelementptr inbounds i8, ptr %src_row_addr, i64 %stride
  %5 = load <vscale x 16 x i8>, ptr %arrayidx2
  %6 = getelementptr <vscale x 16 x i8>, ptr %arrayidx2, i64 1
  %7 = load <vscale x 16 x i8>, ptr %6
  %8 = add <vscale x 16 x i8> %2, %5
  %9 = add <vscale x 16 x i8> %4, %7
  %10 = bitcast <vscale x 16 x i8> %8 to <vscale x 8 x i16>
  %11 = trunc <vscale x 8 x i16> %10 to <vscale x 8 x i8>
  store <vscale x 8 x i8> %11, ptr %dst_row_addr
  %12 = bitcast <vscale x 16 x i8> %9 to <vscale x 8 x i16>
  %13 = getelementptr <vscale x 8 x i8>, ptr %dst_row_addr, i64 1
  %14 = trunc <vscale x 8 x i16> %12 to <vscale x 8 x i8>
  store <vscale x 8 x i8> %14, ptr %13
  %add_ptr_src = getelementptr inbounds i8, ptr %src_row_addr, i64 %mul
  %add_ptr_dst = getelementptr inbounds i8, ptr %dst_row_addr, i64 %mul
  %inc = add nuw i64 %idx, 1
  %exitcond = icmp eq i64 %inc, %count
  br i1 %exitcond, label %for.exit, label %for.body

for.exit:
  ret void
}

attributes #0 = { "target-features"="+sve2" vscale_range(1,16) }
