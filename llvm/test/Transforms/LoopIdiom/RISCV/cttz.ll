; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -passes=loop-idiom -mtriple=riscv32 -S < %s | FileCheck %s
; RUN: opt -passes=loop-idiom -mtriple=riscv64 -S < %s | FileCheck %s

; Copied from popcnt test.

;To recognize this pattern:
;int ctz(uint32_t n)
;{
;    int count = 0;
;    if (n == 0)
;    {
;        return 32;
;    }
;    while ((n & 1) == 0)
;    {
;        count += 1;
;        n >>= 1;
;    }
;    return count;
;}

define signext i32 @count_trailing_zeroes(i32 noundef signext %n) local_unnamed_addr #0 {
; CHECK-LABEL: @count_trailing_zeroes(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP]], label [[CLEANUP:%.*]], label [[WHILE_COND_PREHEADER:%.*]]
; CHECK:       while.cond.preheader:
; CHECK-NEXT:    [[AND4:%.*]] = and i32 [[N]], 1
; CHECK-NEXT:    [[CMP15:%.*]] = icmp eq i32 [[AND4]], 0
; CHECK-NEXT:    br i1 [[CMP15]], label [[WHILE_BODY_PREHEADER:%.*]], label [[CLEANUP]]
; CHECK:       while.body.preheader:
; CHECK-NEXT:    [[TMP0:%.*]] = call i32 @llvm.cttz.i32(i32 [[N]], i1 true)
; CHECK-NEXT:    br label [[WHILE_BODY:%.*]]
; CHECK:       while.body:
; CHECK-NEXT:    [[COUNT_07:%.*]] = phi i32 [ [[ADD:%.*]], [[WHILE_BODY]] ], [ 0, [[WHILE_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[N_ADDR_06:%.*]] = phi i32 [ [[SHR:%.*]], [[WHILE_BODY]] ], [ [[N]], [[WHILE_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[ADD]] = add nuw nsw i32 [[COUNT_07]], 1
; CHECK-NEXT:    [[SHR]] = lshr i32 [[N_ADDR_06]], 1
; CHECK-NEXT:    [[TMP1:%.*]] = and i32 [[N_ADDR_06]], 2
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i32 [[TMP1]], 0
; CHECK-NEXT:    br i1 [[CMP1]], label [[WHILE_BODY]], label [[CLEANUP_LOOPEXIT:%.*]]
; CHECK:       cleanup.loopexit:
; CHECK-NEXT:    [[ADD_LCSSA:%.*]] = phi i32 [ [[TMP0]], [[WHILE_BODY]] ]
; CHECK-NEXT:    br label [[CLEANUP]]
; CHECK:       cleanup:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 32, [[ENTRY:%.*]] ], [ 0, [[WHILE_COND_PREHEADER]] ], [ [[ADD_LCSSA]], [[CLEANUP_LOOPEXIT]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %cmp = icmp eq i32 %n, 0
  br i1 %cmp, label %cleanup, label %while.cond.preheader

while.cond.preheader:                             ; preds = %entry
  %and4 = and i32 %n, 1
  %cmp15 = icmp eq i32 %and4, 0
  br i1 %cmp15, label %while.body, label %cleanup

while.body:                                       ; preds = %while.cond.preheader, %while.body
  %count.07 = phi i32 [ %add, %while.body ], [ 0, %while.cond.preheader ]
  %n.addr.06 = phi i32 [ %shr, %while.body ], [ %n, %while.cond.preheader ]
  %add = add nuw nsw i32 %count.07, 1
  %shr = lshr i32 %n.addr.06, 1
  %0 = and i32 %n.addr.06, 2
  %cmp1 = icmp eq i32 %0, 0
  br i1 %cmp1, label %while.body, label %cleanup

cleanup:                                          ; preds = %while.body, %while.cond.preheader, %entry
  %retval.0 = phi i32 [ 32, %entry ], [ 0, %while.cond.preheader ], [ %add, %while.body ]
  ret i32 %retval.0
}

;int ctz(uint64_t n)
;{
;    int count = 0;
;    if (n != 0)
;    {
;        while ((n & 1) == 0)
;        {
;            n >>= 1;
;            count += 1;
;        }
;    }
;    else
;    {
;        return 64;
;    }
;    return count;
;}

define dso_local signext i32 @ctz(i64 noundef %n) local_unnamed_addr {
; CHECK-LABEL: @ctz(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp eq i64 [[N:%.*]], 0
; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[CLEANUP:%.*]], label [[WHILE_COND_PREHEADER:%.*]]
; CHECK:       while.cond.preheader:
; CHECK-NEXT:    [[AND5:%.*]] = and i64 [[N]], 1
; CHECK-NEXT:    [[CMP16:%.*]] = icmp eq i64 [[AND5]], 0
; CHECK-NEXT:    br i1 [[CMP16]], label [[WHILE_BODY_PREHEADER:%.*]], label [[CLEANUP]]
; CHECK:       while.body.preheader:
; CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cttz.i64(i64 [[N]], i1 true)
; CHECK-NEXT:    [[TMP1:%.*]] = trunc i64 [[TMP0]] to i32
; CHECK-NEXT:    br label [[WHILE_BODY:%.*]]
; CHECK:       while.body:
; CHECK-NEXT:    [[COUNT_08:%.*]] = phi i32 [ [[ADD:%.*]], [[WHILE_BODY]] ], [ 0, [[WHILE_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[N_ADDR_07:%.*]] = phi i64 [ [[SHR:%.*]], [[WHILE_BODY]] ], [ [[N]], [[WHILE_BODY_PREHEADER]] ]
; CHECK-NEXT:    [[SHR]] = lshr i64 [[N_ADDR_07]], 1
; CHECK-NEXT:    [[ADD]] = add nuw nsw i32 [[COUNT_08]], 1
; CHECK-NEXT:    [[TMP2:%.*]] = and i64 [[N_ADDR_07]], 2
; CHECK-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[TMP2]], 0
; CHECK-NEXT:    br i1 [[CMP1]], label [[WHILE_BODY]], label [[CLEANUP_LOOPEXIT:%.*]]
; CHECK:       cleanup.loopexit:
; CHECK-NEXT:    [[ADD_LCSSA:%.*]] = phi i32 [ [[TMP1]], [[WHILE_BODY]] ]
; CHECK-NEXT:    br label [[CLEANUP]]
; CHECK:       cleanup:
; CHECK-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 64, [[ENTRY:%.*]] ], [ 0, [[WHILE_COND_PREHEADER]] ], [ [[ADD_LCSSA]], [[CLEANUP_LOOPEXIT]] ]
; CHECK-NEXT:    ret i32 [[RETVAL_0]]
;
entry:
  %cmp.not = icmp eq i64 %n, 0
  br i1 %cmp.not, label %cleanup, label %while.cond.preheader

while.cond.preheader:                             ; preds = %entry
  %and5 = and i64 %n, 1
  %cmp16 = icmp eq i64 %and5, 0
  br i1 %cmp16, label %while.body.preheader, label %cleanup

while.body.preheader:                             ; preds = %while.cond.preheader
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %while.body
  %count.08 = phi i32 [ %add, %while.body ], [ 0, %while.body.preheader ]
  %n.addr.07 = phi i64 [ %shr, %while.body ], [ %n, %while.body.preheader ]
  %shr = lshr i64 %n.addr.07, 1
  %add = add nuw nsw i32 %count.08, 1
  %0 = and i64 %n.addr.07, 2
  %cmp1 = icmp eq i64 %0, 0
  br i1 %cmp1, label %while.body, label %cleanup.loopexit

cleanup.loopexit:                                 ; preds = %while.body
  %add.lcssa = phi i32 [ %add, %while.body ]
  br label %cleanup

cleanup:                                          ; preds = %cleanup.loopexit, %while.cond.preheader, %entry
  %retval.0 = phi i32 [ 64, %entry ], [ 0, %while.cond.preheader ], [ %add.lcssa, %cleanup.loopexit ]
  ret i32 %retval.0
}
