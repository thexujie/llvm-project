; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; test phi combine less than (equal)
define i1 @src0(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src0(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[A:%.*]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umin.i32(i32 6, i32 %a)
  br label %loop
loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ult i32 %ind, 6
  ret i1 %cmp
}

; test phi combine less than (swapped) good
define i1 @src1(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src1(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[A:%.*]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umax.i32(i32 6, i32 %a)
  br label %loop
loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ult i32 6, %ind
  ret i1 %cmp
}

; test phi combine less than (swapped) bad
define i1 @src2(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src2(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[MIN:%.*]] = call i32 @llvm.umax.i32(i32 [[A:%.*]], i32 6)
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[MIN]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umax.i32(i32 6, i32 %a)
  br label %loop
loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ugt i32 6, %ind
  ret i1 %cmp
}


; test phi combine less than (reversed)
define i1 @src3(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src3(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[A:%.*]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umin.i32(i32 %a, i32 6)
  br label %loop

loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ult i32 %ind, 6
  ret i1 %cmp
}

; test phi combine less than (over)
define i1 @src4(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src4(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[A:%.*]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umin.i32(i32 %a, i32 7)
  br label %loop

loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ult i32 %ind, 6
  ret i1 %cmp
}

; test phi combine less than (under)
define i1 @src5(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src5(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[MIN:%.*]] = call i32 @llvm.umin.i32(i32 [[A:%.*]], i32 5)
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[MIN]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umin.i32(i32 %a, i32 5)
  br label %loop

loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ult i32 %ind, 6
  ret i1 %cmp
}

; test phi combine greater than (equal)
define i1 @src6(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src6(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[A:%.*]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umax.i32(i32 %a, i32 6)
  br label %loop

loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ugt i32 %ind, 6
  ret i1 %cmp
}

; test phi combine greater than (over)
define i1 @src7(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src7(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[MIN:%.*]] = call i32 @llvm.umax.i32(i32 [[A:%.*]], i32 7)
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[MIN]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umax.i32(i32 %a, i32 7)
  br label %loop

loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ugt i32 %ind, 6
  ret i1 %cmp
}

; test phi combine greater than (under)
define i1 @src8(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src8(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[A:%.*]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umax.i32(i32 %a, i32 5)
  br label %loop

loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ugt i32 %ind, 6
  ret i1 %cmp
}

; test phi combine greater than (swapped-equal) good
define i1 @src9(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src9(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[A:%.*]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umin.i32(i32 %a, i32 6)
  br label %loop
loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ugt i32 6, %ind
  ret i1 %cmp
}

; test phi combine greater than (swapped-over) good
define i1 @src11(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src11(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[A:%.*]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umin.i32(i32 %a, i32 7)
  br label %loop
loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ugt i32 6, %ind
  ret i1 %cmp
}

; test phi combine greater than (swapped-under) bad
define i1 @src12(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src12(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[MIN:%.*]] = call i32 @llvm.umin.i32(i32 [[A:%.*]], i32 5)
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[MIN]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umin.i32(i32 %a, i32 5)
  br label %loop
loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ugt i32 6, %ind
  ret i1 %cmp
}

; test phi combine less than (swapped-equal) bad
define i1 @src13(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src13(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[MIN:%.*]] = call i32 @llvm.umin.i32(i32 [[A:%.*]], i32 6)
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ [[MIN]], [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umin.i32(i32 %a, i32 6)
  br label %loop
loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ult i32 6, %ind
  ret i1 %cmp
}

; test phi combine (min) both value defined
define i1 @src14(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src14(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ 6, [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ugt i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umin.i32(i32 7, i32 6)
  br label %loop
loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ult i32 6, %ind
  ret i1 %cmp
}

; test phi combine (max) both value defined
define i1 @src15(i32 %a, i32 %b, i1 %c) {
; CHECK-LABEL: @src15(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[C:%.*]], label [[THEN:%.*]], label [[LOOP:%.*]]
; CHECK:       then:
; CHECK-NEXT:    br label [[LOOP]]
; CHECK:       loop:
; CHECK-NEXT:    [[IND:%.*]] = phi i32 [ 7, [[THEN]] ], [ [[B:%.*]], [[ENTRY:%.*]] ]
; CHECK-NEXT:    [[CMP:%.*]] = icmp ult i32 [[IND]], 6
; CHECK-NEXT:    ret i1 [[CMP]]
;
entry:
  br i1 %c, label %then, label %loop
then:
  %min = call i32 @llvm.umax.i32(i32 7, i32 6)
  br label %loop
loop:
  %ind = phi i32 [ %min, %then ], [ %b, %entry ]
  %cmp = icmp ugt i32 6, %ind
  ret i1 %cmp
}
