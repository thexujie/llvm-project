; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -p=gvn < %s | FileCheck %s -check-prefixes=GVN,OLDGVN
; RUN: opt -S -p=newgvn < %s | FileCheck %s -check-prefixes=GVN,NEWGVN

define float @test1(i32 %V1, ptr %P) {
; GVN-LABEL: @test1(
; GVN-NEXT:    store i32 [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP1:%.*]] = bitcast i32 [[V1]] to float
; GVN-NEXT:    ret float [[TMP1]]
;
  store i32 %V1, ptr %P, align 1
  %V2 = load float, ptr %P, align 1
  ret float %V2
}

define float @test2(ptr %V1, ptr %P) {
; GVN-LABEL: @test2(
; GVN-NEXT:    store ptr [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[V1]] to i64
; GVN-NEXT:    [[TMP2:%.*]] = trunc i64 [[TMP1]] to i32
; GVN-NEXT:    [[TMP3:%.*]] = bitcast i32 [[TMP2]] to float
; GVN-NEXT:    ret float [[TMP3]]
;
  store ptr %V1, ptr %P, align 1
  %V2 = load float, ptr %P, align 1
  ret float %V2
}

define i8 @test3(i32 %V1, ptr %P) {
; GVN-LABEL: @test3(
; GVN-NEXT:    store i32 [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP1:%.*]] = trunc i32 [[V1]] to i8
; GVN-NEXT:    ret i8 [[TMP1]]
;
  store i32 %V1, ptr %P, align 1
  %V2 = load i8, ptr %P, align 1
  ret i8 %V2
}

define float @test4(i64 %V1, ptr %P) {
; GVN-LABEL: @test4(
; GVN-NEXT:    store i64 [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP1:%.*]] = trunc i64 [[V1]] to i32
; GVN-NEXT:    [[TMP2:%.*]] = bitcast i32 [[TMP1]] to float
; GVN-NEXT:    ret float [[TMP2]]
;
  store i64 %V1, ptr %P, align 1
  %V2 = load float, ptr %P, align 1
  ret float %V2
}

define i8 @test5(ptr %P, ptr %T) {
; GVN-LABEL: @test5(
; GVN-NEXT:    [[V1:%.*]] = load i8, ptr [[T:%.*]], align 1
; GVN-NEXT:    [[P2:%.*]] = getelementptr i8, ptr [[P:%.*]], i32 2
; GVN-NEXT:    store i8 [[V1]], ptr [[P2]], align 1
; GVN-NEXT:    ret i8 [[V1]]
;
  %V1 = load i8, ptr %T, align 1
  %P2 = getelementptr i8, ptr %P, i32 2
  store i8 %V1, ptr %P2, align 1
  %V2 = load i8, ptr %P2, align 1
  ret i8 %V2
}

define ptr @test6(i64 %V1, ptr %P) {
; GVN-LABEL: @test6(
; GVN-NEXT:    store i64 [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[V1]] to ptr
; GVN-NEXT:    ret ptr [[TMP1]]
;
  store i64 %V1, ptr %P, align 1
  %V2 = load ptr, ptr %P, align 1
  ret ptr %V2
}

define i32 @test7(double %V1, ptr %P) {
; GVN-LABEL: @test7(
; GVN-NEXT:    store double [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP1:%.*]] = bitcast double [[V1]] to i64
; GVN-NEXT:    [[TMP2:%.*]] = trunc i64 [[TMP1]] to i32
; GVN-NEXT:    ret i32 [[TMP2]]
;
  store double %V1, ptr %P, align 1
  %V2 = load i32, ptr %P, align 1
  ret i32 %V2
}

define i8 @test8(i32 %V1, ptr %P) {
; OLDGVN-LABEL: @test8(
; OLDGVN-NEXT:    store i32 [[V1:%.*]], ptr [[P:%.*]], align 1
; OLDGVN-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i32 2
; OLDGVN-NEXT:    [[TMP1:%.*]] = lshr i32 [[V1]], 16
; OLDGVN-NEXT:    [[TMP2:%.*]] = trunc i32 [[TMP1]] to i8
; OLDGVN-NEXT:    ret i8 [[TMP2]]
;
; NEWGVN-LABEL: @test8(
; NEWGVN-NEXT:    store i32 [[V1:%.*]], ptr [[P:%.*]], align 1
; NEWGVN-NEXT:    [[TMP1:%.*]] = lshr i32 [[V1]], 16
; NEWGVN-NEXT:    [[TMP2:%.*]] = trunc i32 [[TMP1]] to i8
; NEWGVN-NEXT:    [[P1:%.*]] = getelementptr i8, ptr [[P]], i32 2
; NEWGVN-NEXT:    ret i8 [[TMP2]]
;
  store i32 %V1, ptr %P, align 1
  %P1 = getelementptr i8, ptr %P, i32 2
  %V2 = load i8, ptr %P1, align 1
  ret i8 %V2
}

define double @test9(i64 %V, ptr %P, i1 %cond) {
;   Entry
;    /  \
;   T    F
;
; GVN-LABEL: @test9(
; GVN-NEXT:  Entry:
; GVN-NEXT:    store i64 [[V:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP0:%.*]] = bitcast i64 [[V]] to double
; GVN-NEXT:    br i1 [[COND:%.*]], label [[T:%.*]], label [[F:%.*]]
; GVN:       T:
; GVN-NEXT:    ret double [[TMP0]]
; GVN:       F:
; GVN-NEXT:    ret double [[TMP0]]
;
Entry:
  %A = load i64 , ptr %P, align 1
  store i64 %V, ptr %P, align 1
  br i1 %cond, label %T, label %F
T:
  %B = load double, ptr %P, align 1
  ret double %B

F:
  %C = load double, ptr %P, align 1
  ret double %C
}

define <{i8, float}> @test10(i32 %V0, ptr %P) {
; OLDGVN-LABEL: @test10(
; OLDGVN-NEXT:    store i32 [[V0:%.*]], ptr [[P:%.*]], align 1
; OLDGVN-NEXT:    [[TMP1:%.*]] = bitcast i32 [[V0]] to float
; OLDGVN-NEXT:    [[TMP2:%.*]] = trunc i32 [[V0]] to i8
; OLDGVN-NEXT:    [[I1:%.*]] = insertvalue <{ i8, float }> poison, i8 [[TMP2]], 0
; OLDGVN-NEXT:    [[I2:%.*]] = insertvalue <{ i8, float }> [[I1]], float [[TMP1]], 1
; OLDGVN-NEXT:    ret <{ i8, float }> [[I2]]
;
; NEWGVN-LABEL: @test10(
; NEWGVN-NEXT:    store i32 [[V0:%.*]], ptr [[P:%.*]], align 1
; NEWGVN-NEXT:    [[TMP1:%.*]] = trunc i32 [[V0]] to i8
; NEWGVN-NEXT:    [[TMP2:%.*]] = bitcast i32 [[V0]] to float
; NEWGVN-NEXT:    [[I1:%.*]] = insertvalue <{ i8, float }> poison, i8 [[TMP1]], 0
; NEWGVN-NEXT:    [[I2:%.*]] = insertvalue <{ i8, float }> [[I1]], float [[TMP2]], 1
; NEWGVN-NEXT:    ret <{ i8, float }> [[I2]]
;
  store i32 %V0, ptr %P, align 1
  %V1 = load float, ptr %P, align 1
  %V2 = load i8, ptr %P, align 1
  %I1 = insertvalue <{i8, float}> poison, i8 %V2, 0
  %I2 = insertvalue <{i8, float}> %I1, float %V1, 1
  ret <{i8, float}> %I2
}

define <{i8, float}> @test11(i32 %V0, ptr %P, i1 %cond) {
;   Entry
;    /  \
;   T    F
;
; GVN-LABEL: @test11(
; GVN-NEXT:  Entry:
; GVN-NEXT:    store i32 [[V0:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP0:%.*]] = trunc i32 [[V0]] to i8
; GVN-NEXT:    [[TMP1:%.*]] = bitcast i32 [[V0]] to float
; GVN-NEXT:    br i1 [[COND:%.*]], label [[T:%.*]], label [[F:%.*]]
; GVN:       T:
; GVN-NEXT:    [[I1:%.*]] = insertvalue <{ i8, float }> poison, float [[TMP1]], 1
; GVN-NEXT:    ret <{ i8, float }> [[I1]]
; GVN:       F:
; GVN-NEXT:    [[I2:%.*]] = insertvalue <{ i8, float }> poison, i8 [[TMP0]], 0
; GVN-NEXT:    ret <{ i8, float }> [[I2]]
;
Entry:
  store i32 %V0, ptr %P, align 1
  br i1 %cond, label %T, label %F

T:
  %V1 = load float, ptr %P, align 1
  %I1 = insertvalue <{i8, float}> poison, float %V1, 1
  ret <{i8, float}> %I1

F:
  %V2 = load i8, ptr %P, align 1
  %I2 = insertvalue <{i8, float}> poison, i8 %V2, 0
  ret <{i8, float}> %I2
}

define <{float, float}> @test12(i32 %V0, ptr %P, i1 %cond) {
;   Entry
;    /  \
;   T    F
;
; GVN-LABEL: @test12(
; GVN-NEXT:  Entry:
; GVN-NEXT:    store i32 [[V0:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP0:%.*]] = bitcast i32 [[V0]] to float
; GVN-NEXT:    br i1 [[COND:%.*]], label [[T:%.*]], label [[F:%.*]]
; GVN:       T:
; GVN-NEXT:    [[I1:%.*]] = insertvalue <{ float, float }> poison, float [[TMP0]], 1
; GVN-NEXT:    ret <{ float, float }> [[I1]]
; GVN:       F:
; GVN-NEXT:    [[I2:%.*]] = insertvalue <{ float, float }> poison, float [[TMP0]], 0
; GVN-NEXT:    ret <{ float, float }> [[I2]]
;
Entry:
  store i32 %V0, ptr %P, align 1
  br i1 %cond, label %T, label %F

T:
  %V1 = load float, ptr %P, align 1
  %I1 = insertvalue <{float, float}> poison, float %V1, 1
  ret <{float, float}> %I1

F:
  %V2 = load float, ptr %P, align 1
  %I2 = insertvalue <{float, float}> poison, float %V2, 0
  ret <{float, float}> %I2
}

define i8 @test13(ptr %P, i32 %V1) {
; GVN-LABEL: @test13(
; GVN-NEXT:    store i32 [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP1:%.*]] = trunc i32 [[V1]] to i8
; GVN-NEXT:    [[V5:%.*]] = add i8 [[TMP1]], [[TMP1]]
; GVN-NEXT:    ret i8 [[V5]]
;
  store i32 %V1, ptr %P, align 1
  %V2 = load i8, ptr %P, align 1
  %V3 = load i64, ptr %P, align 1
  %V4 = trunc i32 %V1 to i8
  %V5 = add i8 %V2, %V4
  ret i8 %V5
}

define i8 @test14(ptr %P, i32 %V1) {
; GVN-LABEL: @test14(
; GVN-NEXT:    store i32 [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[TMP1:%.*]] = trunc i32 [[V1]] to i8
; GVN-NEXT:    [[V5:%.*]] = add i8 [[TMP1]], [[TMP1]]
; GVN-NEXT:    ret i8 [[V5]]
;
  store i32 %V1, ptr %P, align 1
  %V2 = load i8, ptr %P, align 1
  %V3 = load i8, ptr %P, align 1
  %V5 = add i8 %V2, %V3
  ret i8 %V5
}

define i16 @test15(ptr %P, i1 %Cond) {
;   Entry
;    /  \
;   T    F
;    \  /
;     vv
;    Exit
;
; GVN-LABEL: @test15(
; GVN-NEXT:  Entry:
; GVN-NEXT:    store i32 13, ptr [[P:%.*]], align 1
; GVN-NEXT:    br i1 [[COND:%.*]], label [[T:%.*]], label [[F:%.*]]
; GVN:       T:
; GVN-NEXT:    br label [[EXIT:%.*]]
; GVN:       F:
; GVN-NEXT:    br label [[EXIT]]
; GVN:       Exit:
; GVN-NEXT:    ret i16 13
;
Entry:
  store i32 13, ptr %P, align 1
  br i1 %Cond, label %T, label %F

T:
  %V1 = load i16, ptr %P, align 1
  br label %Exit

F:
  %V2 = load i32, ptr %P, align 1
  br label %Exit

Exit:
  %V3 = load i16, ptr %P, align 1
  ret i16 %V3
}

define i64 @test16(ptr %V1) {
; GVN-LABEL: @test16(
; GVN-NEXT:  Entry:
; GVN-NEXT:    store ptr [[V1:%.*]], ptr inttoptr (i64 16 to ptr), align 8
; GVN-NEXT:    [[V3:%.*]] = load i64, ptr [[V1]], align 4
; GVN-NEXT:    ret i64 [[V3]]
;
Entry:
  store ptr %V1, ptr inttoptr (i64 16 to ptr), align 8
  %V2 = load ptr, ptr inttoptr (i64 16 to ptr), align 8
  %V3 = load i64, ptr %V2
  ret i64 %V3
}

declare void @foo1(ptr, i32) #0

define i32 @test17(ptr %P, i32 %V1) {
; GVN-LABEL: @test17(
; GVN-NEXT:    store i32 [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[V2:%.*]] = call i32 @foo1(ptr [[P]], i32 [[V1]]) #[[ATTR0:[0-9]+]]
; GVN-NEXT:    [[V3:%.*]] = load i32, ptr [[P]], align 1
; GVN-NEXT:    [[V4:%.*]] = add i32 [[V2]], [[V3]]
; GVN-NEXT:    ret i32 [[V4]]
;
  store i32 %V1, ptr %P, align 1
  %V2 = call i32 @foo1(ptr %P, i32 %V1) #0
  %V3 = load i32, ptr %P, align 1
  %V4 = add i32 %V2, %V3
  ret i32 %V4
}

declare void @foo2(ptr, i32) #1

define i32 @test18(ptr %P, i32 %V1) {
; GVN-LABEL: @test18(
; GVN-NEXT:    store i32 [[V1:%.*]], ptr [[P:%.*]], align 1
; GVN-NEXT:    [[V2:%.*]] = call i32 @foo2(ptr [[P]], i32 [[V1]]) #[[ATTR1:[0-9]+]]
; GVN-NEXT:    [[V4:%.*]] = add i32 [[V2]], [[V1]]
; GVN-NEXT:    ret i32 [[V4]]
;
  store i32 %V1, ptr %P, align 1
  %V2 = call i32 @foo2(ptr %P, i32 %V1) #1
  %V3 = load i32, ptr %P, align 1
  %V4 = add i32 %V2, %V3
  ret i32 %V4
}

attributes #0 = { willreturn }
attributes #1 = { readonly }
