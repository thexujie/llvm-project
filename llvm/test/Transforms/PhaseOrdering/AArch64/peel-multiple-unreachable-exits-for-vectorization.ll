; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -O2 -mtriple=arm64-apple-ios -S %s | FileCheck %s

%vec = type { ptr, ptr }

; Test to ensure a loop with multiple loads guarded by runtime-checks (like
; from multiple calls to C++'s std::vector::at) can be vectorized after
; hoisting the runtime checks out of the loop.

define i64 @sum_2_at_with_int_conversion(ptr %A, ptr %B, i64 %N) {
; CHECK-LABEL: @sum_2_at_with_int_conversion(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[START_I:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-NEXT:    [[GEP_END_I:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[END_I:%.*]] = load ptr, ptr [[GEP_END_I]], align 8
; CHECK-NEXT:    [[START_INT_I:%.*]] = ptrtoint ptr [[START_I]] to i64
; CHECK-NEXT:    [[END_INT_I:%.*]] = ptrtoint ptr [[END_I]] to i64
; CHECK-NEXT:    [[SUB_I:%.*]] = sub i64 [[END_INT_I]], [[START_INT_I]]
; CHECK-NEXT:    [[START_I1:%.*]] = load ptr, ptr [[B:%.*]], align 8
; CHECK-NEXT:    [[GEP_END_I2:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[END_I3:%.*]] = load ptr, ptr [[GEP_END_I2]], align 8
; CHECK-NEXT:    [[START_INT_I4:%.*]] = ptrtoint ptr [[START_I1]] to i64
; CHECK-NEXT:    [[END_INT_I5:%.*]] = ptrtoint ptr [[END_I3]] to i64
; CHECK-NEXT:    [[SUB_I6:%.*]] = sub i64 [[END_INT_I5]], [[START_INT_I4]]
; CHECK-NEXT:    [[SMAX:%.*]] = tail call i64 @llvm.smax.i64(i64 [[N:%.*]], i64 0)
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[AT_WITH_INT_CONVERSION_EXIT11:%.*]] ]
; CHECK-NEXT:    [[SUM:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[SUM_NEXT:%.*]], [[AT_WITH_INT_CONVERSION_EXIT11]] ]
; CHECK-NEXT:    [[INRANGE_I:%.*]] = icmp ugt i64 [[IV]], [[SUB_I]]
; CHECK-NEXT:    br i1 [[INRANGE_I]], label [[ERROR_I:%.*]], label [[AT_WITH_INT_CONVERSION_EXIT:%.*]]
; CHECK:       error.i:
; CHECK-NEXT:    tail call void @error()
; CHECK-NEXT:    unreachable
; CHECK:       at_with_int_conversion.exit:
; CHECK-NEXT:    [[INRANGE_I7:%.*]] = icmp ugt i64 [[IV]], [[SUB_I6]]
; CHECK-NEXT:    br i1 [[INRANGE_I7]], label [[ERROR_I10:%.*]], label [[AT_WITH_INT_CONVERSION_EXIT11]]
; CHECK:       error.i10:
; CHECK-NEXT:    tail call void @error()
; CHECK-NEXT:    unreachable
; CHECK:       at_with_int_conversion.exit11:
; CHECK-NEXT:    [[GEP_IDX_I:%.*]] = getelementptr i64, ptr [[START_I]], i64 [[IV]]
; CHECK-NEXT:    [[LV_I:%.*]] = load i64, ptr [[GEP_IDX_I]], align 8
; CHECK-NEXT:    [[GEP_IDX_I8:%.*]] = getelementptr i64, ptr [[START_I1]], i64 [[IV]]
; CHECK-NEXT:    [[LV_I9:%.*]] = load i64, ptr [[GEP_IDX_I8]], align 8
; CHECK-NEXT:    [[ADD:%.*]] = add i64 [[LV_I]], [[SUM]]
; CHECK-NEXT:    [[SUM_NEXT]] = add i64 [[ADD]], [[LV_I9]]
; CHECK-NEXT:    [[IV_NEXT]] = add nuw i64 [[IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[IV]], [[SMAX]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    ret i64 [[SUM_NEXT]]
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %sum = phi i64 [ 0, %entry ], [ %sum.next, %loop ]
  %a = call i64 @at_with_int_conversion(ptr %A, i64 %iv)
  %b = call i64 @at_with_int_conversion(ptr %B, i64 %iv)
  %add = add i64 %a, %b
  %sum.next = add i64 %sum, %add
  %iv.next = add nuw nsw i64 %iv, 1
  %c = icmp slt i64 %iv, %N
  br i1 %c, label %loop, label %exit

exit:
  ret i64 %sum.next
}

define i64 @sum_3_at_with_int_conversion(ptr %A, ptr %B, ptr %C, i64 %N) {
; CHECK-LABEL: @sum_3_at_with_int_conversion(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[START_I:%.*]] = load ptr, ptr [[A:%.*]], align 8
; CHECK-NEXT:    [[GEP_END_I:%.*]] = getelementptr i8, ptr [[A]], i64 8
; CHECK-NEXT:    [[END_I:%.*]] = load ptr, ptr [[GEP_END_I]], align 8
; CHECK-NEXT:    [[START_INT_I:%.*]] = ptrtoint ptr [[START_I]] to i64
; CHECK-NEXT:    [[END_INT_I:%.*]] = ptrtoint ptr [[END_I]] to i64
; CHECK-NEXT:    [[SUB_I:%.*]] = sub i64 [[END_INT_I]], [[START_INT_I]]
; CHECK-NEXT:    [[START_I1:%.*]] = load ptr, ptr [[B:%.*]], align 8
; CHECK-NEXT:    [[GEP_END_I2:%.*]] = getelementptr i8, ptr [[B]], i64 8
; CHECK-NEXT:    [[END_I3:%.*]] = load ptr, ptr [[GEP_END_I2]], align 8
; CHECK-NEXT:    [[START_INT_I4:%.*]] = ptrtoint ptr [[START_I1]] to i64
; CHECK-NEXT:    [[END_INT_I5:%.*]] = ptrtoint ptr [[END_I3]] to i64
; CHECK-NEXT:    [[SUB_I6:%.*]] = sub i64 [[END_INT_I5]], [[START_INT_I4]]
; CHECK-NEXT:    [[START_I12:%.*]] = load ptr, ptr [[C:%.*]], align 8
; CHECK-NEXT:    [[GEP_END_I13:%.*]] = getelementptr i8, ptr [[C]], i64 8
; CHECK-NEXT:    [[END_I14:%.*]] = load ptr, ptr [[GEP_END_I13]], align 8
; CHECK-NEXT:    [[START_INT_I15:%.*]] = ptrtoint ptr [[START_I12]] to i64
; CHECK-NEXT:    [[END_INT_I16:%.*]] = ptrtoint ptr [[END_I14]] to i64
; CHECK-NEXT:    [[SUB_I17:%.*]] = sub i64 [[END_INT_I16]], [[START_INT_I15]]
; CHECK-NEXT:    [[SMAX:%.*]] = tail call i64 @llvm.smax.i64(i64 [[N:%.*]], i64 0)
; CHECK-NEXT:    br label [[LOOP:%.*]]
; CHECK:       loop:
; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[IV_NEXT:%.*]], [[AT_WITH_INT_CONVERSION_EXIT22:%.*]] ]
; CHECK-NEXT:    [[SUM:%.*]] = phi i64 [ 0, [[ENTRY]] ], [ [[SUM_NEXT:%.*]], [[AT_WITH_INT_CONVERSION_EXIT22]] ]
; CHECK-NEXT:    [[INRANGE_I:%.*]] = icmp ugt i64 [[IV]], [[SUB_I]]
; CHECK-NEXT:    br i1 [[INRANGE_I]], label [[ERROR_I:%.*]], label [[AT_WITH_INT_CONVERSION_EXIT:%.*]]
; CHECK:       error.i:
; CHECK-NEXT:    tail call void @error()
; CHECK-NEXT:    unreachable
; CHECK:       at_with_int_conversion.exit:
; CHECK-NEXT:    [[GEP_IDX_I:%.*]] = getelementptr i64, ptr [[START_I]], i64 [[IV]]
; CHECK-NEXT:    [[LV_I:%.*]] = load i64, ptr [[GEP_IDX_I]], align 8
; CHECK-NEXT:    [[INRANGE_I7:%.*]] = icmp ugt i64 [[IV]], [[SUB_I6]]
; CHECK-NEXT:    br i1 [[INRANGE_I7]], label [[ERROR_I10:%.*]], label [[AT_WITH_INT_CONVERSION_EXIT11:%.*]]
; CHECK:       error.i10:
; CHECK-NEXT:    tail call void @error()
; CHECK-NEXT:    unreachable
; CHECK:       at_with_int_conversion.exit11:
; CHECK-NEXT:    [[INRANGE_I18:%.*]] = icmp ugt i64 [[IV]], [[SUB_I17]]
; CHECK-NEXT:    br i1 [[INRANGE_I18]], label [[ERROR_I21:%.*]], label [[AT_WITH_INT_CONVERSION_EXIT22]]
; CHECK:       error.i21:
; CHECK-NEXT:    tail call void @error()
; CHECK-NEXT:    unreachable
; CHECK:       at_with_int_conversion.exit22:
; CHECK-NEXT:    [[GEP_IDX_I8:%.*]] = getelementptr i64, ptr [[START_I1]], i64 [[IV]]
; CHECK-NEXT:    [[LV_I9:%.*]] = load i64, ptr [[GEP_IDX_I8]], align 8
; CHECK-NEXT:    [[GEP_IDX_I19:%.*]] = getelementptr i64, ptr [[START_I12]], i64 [[IV]]
; CHECK-NEXT:    [[LV_I20:%.*]] = load i64, ptr [[GEP_IDX_I19]], align 8
; CHECK-NEXT:    [[ADD_1:%.*]] = add i64 [[LV_I]], [[SUM]]
; CHECK-NEXT:    [[ADD_2:%.*]] = add i64 [[ADD_1]], [[LV_I9]]
; CHECK-NEXT:    [[SUM_NEXT]] = add i64 [[ADD_2]], [[LV_I20]]
; CHECK-NEXT:    [[IV_NEXT]] = add nuw i64 [[IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[IV]], [[SMAX]]
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[EXIT:%.*]], label [[LOOP]]
; CHECK:       exit:
; CHECK-NEXT:    ret i64 [[SUM_NEXT]]
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %iv.next, %loop ]
  %sum = phi i64 [ 0, %entry ], [ %sum.next, %loop ]
  %a = call i64 @at_with_int_conversion(ptr %A, i64 %iv)
  %b = call i64 @at_with_int_conversion(ptr %B, i64 %iv)
  %c = call i64 @at_with_int_conversion(ptr %C, i64 %iv)
  %add.1 = add i64 %a, %b
  %add.2 = add i64 %add.1, %c
  %sum.next = add i64 %sum, %add.2
  %iv.next = add nuw nsw i64 %iv, 1
  %cond = icmp slt i64 %iv, %N
  br i1 %cond, label %loop, label %exit

exit:
  ret i64 %sum.next
}


define i64 @at_with_int_conversion(ptr %ptr, i64 %idx) {
; CHECK-LABEL: @at_with_int_conversion(
; CHECK-NEXT:    [[START:%.*]] = load ptr, ptr [[PTR:%.*]], align 8
; CHECK-NEXT:    [[GEP_END:%.*]] = getelementptr i8, ptr [[PTR]], i64 8
; CHECK-NEXT:    [[END:%.*]] = load ptr, ptr [[GEP_END]], align 8
; CHECK-NEXT:    [[START_INT:%.*]] = ptrtoint ptr [[START]] to i64
; CHECK-NEXT:    [[END_INT:%.*]] = ptrtoint ptr [[END]] to i64
; CHECK-NEXT:    [[SUB:%.*]] = sub i64 [[END_INT]], [[START_INT]]
; CHECK-NEXT:    [[INRANGE:%.*]] = icmp ugt i64 [[IDX:%.*]], [[SUB]]
; CHECK-NEXT:    br i1 [[INRANGE]], label [[ERROR:%.*]], label [[EXIT:%.*]]
; CHECK:       exit:
; CHECK-NEXT:    [[GEP_IDX:%.*]] = getelementptr i64, ptr [[START]], i64 [[IDX]]
; CHECK-NEXT:    [[LV:%.*]] = load i64, ptr [[GEP_IDX]], align 8
; CHECK-NEXT:    ret i64 [[LV]]
; CHECK:       error:
; CHECK-NEXT:    tail call void @error()
; CHECK-NEXT:    unreachable
;
  %start = load ptr, ptr %ptr
  %gep.end = getelementptr %vec, ptr %ptr, i64 0, i32 1
  %end = load ptr, ptr %gep.end
  %start.int = ptrtoint ptr %start to i64
  %end.int = ptrtoint ptr %end to i64
  %sub = sub i64 %end.int, %start.int
  %inrange = icmp ugt i64 %idx, %sub
  br i1 %inrange, label %error, label %exit

exit:
  %gep.idx = getelementptr i64, ptr %start, i64 %idx
  %lv = load i64, ptr %gep.idx
  ret i64 %lv

error:
  call void @error()
  unreachable
}

declare void @error()


