; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s -disable-output "-passes=print<scalar-evolution>" -scalar-evolution-classify-expressions=0 -scalar-evolution-infer-max-trip-count-from-memory-access 2>&1 | FileCheck %s

define void @ComputeMaxTripCountFromArrayNormal(i32 signext %len) {
; CHECK-LABEL: 'ComputeMaxTripCountFromArrayNormal'
; CHECK-NEXT:  Determining loop execution counts for: @ComputeMaxTripCountFromArrayNormal
; CHECK-NEXT:  Loop %for.body: backedge-taken count is (-1 + %len)
; CHECK-NEXT:  Loop %for.body: constant max backedge-taken count is 7
; CHECK-NEXT:  Loop %for.body: symbolic max backedge-taken count is (-1 + %len)
; CHECK-NEXT:  Loop %for.body: Predicated backedge-taken count is (-1 + %len)
; CHECK-NEXT:   Predicates:
; CHECK-NEXT:  Loop %for.body: Trip multiple is 1
; CHECK-NEXT:  Loop %for.body: Small constant max trip is 8
;
entry:
  %a = alloca [7 x i32], align 4
  %cmp4 = icmp sgt i32 %len, 0
  br i1 %cmp4, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:
  br label %for.body

for.cond.cleanup.loopexit:
  br label %for.cond.cleanup

for.cond.cleanup:
  ret void

for.body:
  %iv = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %idxprom = zext i32 %iv to i64
  %arrayidx = getelementptr inbounds [7 x i32], [7 x i32]* %a, i64 0, i64 %idxprom
  store i32 0, i32* %arrayidx, align 4
  %inc = add nuw nsw i32 %iv, 1
  %cmp = icmp slt i32 %inc, %len
  br i1 %cmp, label %for.body, label %for.cond.cleanup.loopexit
}


define void @ComputeMaxTripCountFromZeroArray(i32 signext %len) {
; CHECK-LABEL: 'ComputeMaxTripCountFromZeroArray'
; CHECK-NEXT:  Determining loop execution counts for: @ComputeMaxTripCountFromZeroArray
; CHECK-NEXT:  Loop %for.body: backedge-taken count is (-1 + %len)
; CHECK-NEXT:  Loop %for.body: constant max backedge-taken count is 0
; CHECK-NEXT:  Loop %for.body: symbolic max backedge-taken count is (-1 + %len)
; CHECK-NEXT:  Loop %for.body: Predicated backedge-taken count is (-1 + %len)
; CHECK-NEXT:   Predicates:
; CHECK-NEXT:  Loop %for.body: Trip multiple is 1
; CHECK-NEXT:  Loop %for.body: Small constant max trip is 1
;
entry:
  %a = alloca [0 x i32], align 4
  %cmp4 = icmp sgt i32 %len, 0
  br i1 %cmp4, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:
  br label %for.body

for.cond.cleanup.loopexit:
  br label %for.cond.cleanup

for.cond.cleanup:
  ret void

for.body:
  %iv = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %idxprom = zext i32 %iv to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* %a, i64 0, i64 %idxprom
  store i32 0, i32* %arrayidx, align 4
  %inc = add nuw nsw i32 %iv, 1
  %cmp = icmp slt i32 %inc, %len
  br i1 %cmp, label %for.body, label %for.cond.cleanup.loopexit
}

define void @ComputeMaxTripCountFromExtremArray(i32 signext %len) {
; CHECK-LABEL: 'ComputeMaxTripCountFromExtremArray'
; CHECK-NEXT:  Determining loop execution counts for: @ComputeMaxTripCountFromExtremArray
; CHECK-NEXT:  Loop %for.body: backedge-taken count is (-1 + %len)
; CHECK-NEXT:  Loop %for.body: constant max backedge-taken count is 2147483646
; CHECK-NEXT:  Loop %for.body: symbolic max backedge-taken count is (-1 + %len)
; CHECK-NEXT:  Loop %for.body: Predicated backedge-taken count is (-1 + %len)
; CHECK-NEXT:   Predicates:
; CHECK-NEXT:  Loop %for.body: Trip multiple is 1
; CHECK-NEXT:  Loop %for.body: Small constant max trip is 2147483647
;
entry:
  %a = alloca [4294967295 x i1], align 4
  %cmp4 = icmp sgt i32 %len, 0
  br i1 %cmp4, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:
  br label %for.body

for.cond.cleanup.loopexit:
  br label %for.cond.cleanup

for.cond.cleanup:
  ret void

for.body:
  %iv = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %idxprom = zext i32 %iv to i64
  %arrayidx = getelementptr inbounds [4294967295 x i1], [4294967295 x i1]* %a, i64 0, i64 %idxprom
  store i1 0, i1* %arrayidx, align 4
  %inc = add nuw nsw i32 %iv, 1
  %cmp = icmp slt i32 %inc, %len
  br i1 %cmp, label %for.body, label %for.cond.cleanup.loopexit
}


define void @ComputeMaxTripCountFromArrayInBranch(i32 signext %len) {
; CHECK-LABEL: 'ComputeMaxTripCountFromArrayInBranch'
; CHECK-NEXT:  Determining loop execution counts for: @ComputeMaxTripCountFromArrayInBranch
; CHECK-NEXT:  Loop %for.cond: backedge-taken count is (0 smax %len)
; CHECK-NEXT:  Loop %for.cond: constant max backedge-taken count is 2147483647
; CHECK-NEXT:  Loop %for.cond: symbolic max backedge-taken count is (0 smax %len)
; CHECK-NEXT:  Loop %for.cond: Predicated backedge-taken count is (0 smax %len)
; CHECK-NEXT:   Predicates:
; CHECK-NEXT:  Loop %for.cond: Trip multiple is 1
; CHECK-NEXT:  Loop %for.cond: Small constant max trip is 2147483648
;
entry:
  %a = alloca [8 x i32], align 4
  br label %for.cond

for.cond:
  %iv = phi i32 [ %inc, %for.inc ], [ 0, %entry ]
  %cmp = icmp slt i32 %iv, %len
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:
  br label %for.end

for.body:
  %cmp1 = icmp slt i32 %iv, 8
  br i1 %cmp1, label %if.then, label %if.end

if.then:
  %idxprom = sext i32 %iv to i64
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* %a, i64 0, i64 %idxprom
  store i32 0, i32* %arrayidx, align 4
  br label %if.end

if.end:
  br label %for.inc

for.inc:
  %inc = add nsw i32 %iv, 1
  br label %for.cond

for.end:
  ret void
}

define void @ComputeMaxTripCountFromMultiDimArray(i32 signext %len) {
; CHECK-LABEL: 'ComputeMaxTripCountFromMultiDimArray'
; CHECK-NEXT:  Determining loop execution counts for: @ComputeMaxTripCountFromMultiDimArray
; CHECK-NEXT:  Loop %for.cond: backedge-taken count is (0 smax %len)
; CHECK-NEXT:  Loop %for.cond: constant max backedge-taken count is 2147483647
; CHECK-NEXT:  Loop %for.cond: symbolic max backedge-taken count is (0 smax %len)
; CHECK-NEXT:  Loop %for.cond: Predicated backedge-taken count is (0 smax %len)
; CHECK-NEXT:   Predicates:
; CHECK-NEXT:  Loop %for.cond: Trip multiple is 1
; CHECK-NEXT:  Loop %for.cond: Small constant max trip is 2147483648
;
entry:
  %a = alloca [3 x [5 x i32]], align 4
  br label %for.cond

for.cond:
  %iv = phi i32 [ %inc, %for.inc ], [ 0, %entry ]
  %cmp = icmp slt i32 %iv, %len
  br i1 %cmp, label %for.body, label %for.cond.cleanup

for.cond.cleanup:
  br label %for.end

for.body:
  %arrayidx = getelementptr inbounds [3 x [5 x i32]], [3 x [5 x i32]]* %a, i64 0, i64 3
  %idxprom = sext i32 %iv to i64
  %arrayidx1 = getelementptr inbounds [5 x i32], [5 x i32]* %arrayidx, i64 0, i64 %idxprom
  store i32 0, i32* %arrayidx1, align 4
  br label %for.inc

for.inc:
  %inc = add nsw i32 %iv, 1
  br label %for.cond

for.end:
  ret void
}
