; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN:  llc -amdgpu-scalarize-global-loads=false  -mtriple=amdgcn-- -verify-machineinstrs < %s | FileCheck -enable-var-scope --check-prefixes=GCN,SI,FUNC %s
; RUN:  llc -amdgpu-scalarize-global-loads=false  -mtriple=amdgcn-- -mcpu=tonga -mattr=-flat-for-global -verify-machineinstrs < %s | FileCheck -enable-var-scope --check-prefixes=GCN,GFX89,FUNC %s
; RUN:  llc -amdgpu-scalarize-global-loads=false  -mtriple=amdgcn-- -mcpu=gfx900 -mattr=-flat-for-global -verify-machineinstrs < %s | FileCheck -enable-var-scope --check-prefixes=GCN,GFX9,GFX89,FUNC %s
; RUN:  llc -amdgpu-scalarize-global-loads=false  -mtriple=r600 -mtriple=r600-- -mcpu=cypress < %s | FileCheck -enable-var-scope --check-prefixes=EG,FUNC %s

; FIXME: i16 promotion pass ruins the scalar cases when legal.
; FIXME: r600 fails verifier

; FUNC-LABEL: {{^}}sext_in_reg_i1_i32:
; GCN: s_load_dword [[ARG:s[0-9]+]],
; GCN: s_bfe_i32 [[SEXTRACT:s[0-9]+]], [[ARG]], 0x10000
; GCN: v_mov_b32_e32 [[EXTRACT:v[0-9]+]], [[SEXTRACT]]
; GCN: buffer_store_dword [[EXTRACT]],

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+\.[XYZW]]], [[ADDR:T[0-9]+.[XYZW]]]
; EG: LSHR * [[ADDR]]
; EG: BFE_INT * [[RES]], {{.*}}, 0.0, 1
define amdgpu_kernel void @sext_in_reg_i1_i32(ptr addrspace(1) %out, i32 %in) #0 {
; SI-LABEL: sext_in_reg_i1_i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dword s2, s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_bfe_i32 s4, s2, 0x10000
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_dword v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_i1_i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dword s2, s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[4:5], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_bfe_i32 s0, s2, 0x10000
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_i1_i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T1.X, T0.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     LSHR * T0.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     BFE_INT * T1.X, KC0[2].Z, 0.0, 1,
  %shl = shl i32 %in, 31
  %sext = ashr i32 %shl, 31
  store i32 %sext, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_i8_to_i32:
; GCN: s_add_i32 [[VAL:s[0-9]+]],
; GCN: s_sext_i32_i8 [[EXTRACT:s[0-9]+]], [[VAL]]
; GCN: v_mov_b32_e32 [[VEXTRACT:v[0-9]+]], [[EXTRACT]]
; GCN: buffer_store_dword [[VEXTRACT]],

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+\.[XYZW]]], [[ADDR:T[0-9]+.[XYZW]]]
; EG: ADD_INT
; EG-NEXT: BFE_INT [[RES]], {{.*}}, 0.0, literal
; EG-NEXT: LSHR * [[ADDR]]
define amdgpu_kernel void @sext_in_reg_i8_to_i32(ptr addrspace(1) %out, i32 %a, i32 %b) #0 {
; SI-LABEL: sext_in_reg_i8_to_i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s2, s3
; SI-NEXT:    s_sext_i32_i8 s2, s2
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    s_mov_b32 s4, s0
; SI-NEXT:    s_mov_b32 s5, s1
; SI-NEXT:    v_mov_b32_e32 v0, s2
; SI-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX89-LABEL: sext_in_reg_i8_to_i32:
; GFX89:       ; %bb.0:
; GFX89-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX89-NEXT:    s_mov_b32 s7, 0xf000
; GFX89-NEXT:    s_mov_b32 s6, -1
; GFX89-NEXT:    s_waitcnt lgkmcnt(0)
; GFX89-NEXT:    s_mov_b32 s4, s0
; GFX89-NEXT:    s_add_i32 s0, s2, s3
; GFX89-NEXT:    s_sext_i32_i8 s0, s0
; GFX89-NEXT:    s_mov_b32 s5, s1
; GFX89-NEXT:    v_mov_b32_e32 v0, s0
; GFX89-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX89-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_i8_to_i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s4, s0
; GFX9-NEXT:    s_add_i32 s0, s2, s3
; GFX9-NEXT:    s_sext_i32_i8 s0, s0
; GFX9-NEXT:    s_mov_b32 s5, s1
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_i8_to_i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Z, KC0[2].W,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    8(1.121039e-44), 2(2.802597e-45)
  %c = add i32 %a, %b ; add to prevent folding into extload
  %shl = shl i32 %c, 24
  %ashr = ashr i32 %shl, 24
  store i32 %ashr, ptr addrspace(1) %out, align 4
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_i16_to_i32:
; GCN: s_add_i32 [[VAL:s[0-9]+]],
; GCN: s_sext_i32_i16 [[EXTRACT:s[0-9]+]], [[VAL]]
; GCN: v_mov_b32_e32 [[VEXTRACT:v[0-9]+]], [[EXTRACT]]
; GCN: buffer_store_dword [[VEXTRACT]],

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+\.[XYZW]]], [[ADDR:T[0-9]+.[XYZW]]]
; EG: ADD_INT
; EG-NEXT: BFE_INT [[RES]], {{.*}}, 0.0, literal
; EG-NEXT: LSHR * [[ADDR]]
define amdgpu_kernel void @sext_in_reg_i16_to_i32(ptr addrspace(1) %out, i32 %a, i32 %b) #0 {
; SI-LABEL: sext_in_reg_i16_to_i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s2, s3
; SI-NEXT:    s_sext_i32_i16 s2, s2
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    s_mov_b32 s4, s0
; SI-NEXT:    s_mov_b32 s5, s1
; SI-NEXT:    v_mov_b32_e32 v0, s2
; SI-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX89-LABEL: sext_in_reg_i16_to_i32:
; GFX89:       ; %bb.0:
; GFX89-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX89-NEXT:    s_mov_b32 s7, 0xf000
; GFX89-NEXT:    s_mov_b32 s6, -1
; GFX89-NEXT:    s_waitcnt lgkmcnt(0)
; GFX89-NEXT:    s_mov_b32 s4, s0
; GFX89-NEXT:    s_add_i32 s0, s2, s3
; GFX89-NEXT:    s_sext_i32_i16 s0, s0
; GFX89-NEXT:    s_mov_b32 s5, s1
; GFX89-NEXT:    v_mov_b32_e32 v0, s0
; GFX89-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX89-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_i16_to_i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s4, s0
; GFX9-NEXT:    s_add_i32 s0, s2, s3
; GFX9-NEXT:    s_sext_i32_i16 s0, s0
; GFX9-NEXT:    s_mov_b32 s5, s1
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_i16_to_i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Z, KC0[2].W,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    16(2.242078e-44), 2(2.802597e-45)
  %c = add i32 %a, %b ; add to prevent folding into extload
  %shl = shl i32 %c, 16
  %ashr = ashr i32 %shl, 16
  store i32 %ashr, ptr addrspace(1) %out, align 4
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_i8_to_v1i32:
; GCN: s_add_i32 [[VAL:s[0-9]+]],
; GCN: s_sext_i32_i8 [[EXTRACT:s[0-9]+]], [[VAL]]
; GCN: v_mov_b32_e32 [[VEXTRACT:v[0-9]+]], [[EXTRACT]]
; GCN: buffer_store_dword [[VEXTRACT]],

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+\.[XYZW]]], [[ADDR:T[0-9]+.[XYZW]]]
; EG: ADD_INT
; EG-NEXT: BFE_INT [[RES]], {{.*}}, 0.0, literal
; EG-NEXT: LSHR * [[ADDR]]
define amdgpu_kernel void @sext_in_reg_i8_to_v1i32(ptr addrspace(1) %out, <1 x i32> %a, <1 x i32> %b) #0 {
; SI-LABEL: sext_in_reg_i8_to_v1i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s2, s3
; SI-NEXT:    s_sext_i32_i8 s2, s2
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    s_mov_b32 s4, s0
; SI-NEXT:    s_mov_b32 s5, s1
; SI-NEXT:    v_mov_b32_e32 v0, s2
; SI-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX89-LABEL: sext_in_reg_i8_to_v1i32:
; GFX89:       ; %bb.0:
; GFX89-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX89-NEXT:    s_mov_b32 s7, 0xf000
; GFX89-NEXT:    s_mov_b32 s6, -1
; GFX89-NEXT:    s_waitcnt lgkmcnt(0)
; GFX89-NEXT:    s_mov_b32 s4, s0
; GFX89-NEXT:    s_add_i32 s0, s2, s3
; GFX89-NEXT:    s_sext_i32_i8 s0, s0
; GFX89-NEXT:    s_mov_b32 s5, s1
; GFX89-NEXT:    v_mov_b32_e32 v0, s0
; GFX89-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX89-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_i8_to_v1i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s4, s0
; GFX9-NEXT:    s_add_i32 s0, s2, s3
; GFX9-NEXT:    s_sext_i32_i8 s0, s0
; GFX9-NEXT:    s_mov_b32 s5, s1
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_i8_to_v1i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 3, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Z, KC0[2].W,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    8(1.121039e-44), 2(2.802597e-45)
  %c = add <1 x i32> %a, %b ; add to prevent folding into extload
  %shl = shl <1 x i32> %c, <i32 24>
  %ashr = ashr <1 x i32> %shl, <i32 24>
  store <1 x i32> %ashr, ptr addrspace(1) %out, align 4
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_i1_to_i64:
; GCN: s_lshl_b64 [[VAL:s\[[0-9]+:[0-9]+\]]]
; GCN-DAG: s_bfe_i64 s[[[SLO:[0-9]+]]:[[SHI:[0-9]+]]], [[VAL]], 0x10000
; GCN-DAG: v_mov_b32_e32 v[[VLO:[0-9]+]], s[[SLO]]
; GCN-DAG: v_mov_b32_e32 v[[VHI:[0-9]+]], s[[SHI]]
; GCN: buffer_store_dwordx2 v[[[VLO]]:[[VHI]]]
define amdgpu_kernel void @sext_in_reg_i1_to_i64(ptr addrspace(1) %out, i64 %a, i64 %b) #0 {
; SI-LABEL: sext_in_reg_i1_to_i64:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x9
; SI-NEXT:    s_load_dword s0, s[0:1], 0xd
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_lshl_b64 s[0:1], s[6:7], s0
; SI-NEXT:    s_bfe_i64 s[0:1], s[0:1], 0x10000
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    v_mov_b32_e32 v0, s0
; SI-NEXT:    v_mov_b32_e32 v1, s1
; SI-NEXT:    buffer_store_dwordx2 v[0:1], off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_i1_to_i64:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x24
; GFX9-NEXT:    s_load_dword s8, s[0:1], 0x34
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s0, s4
; GFX9-NEXT:    s_mov_b32 s1, s5
; GFX9-NEXT:    s_lshl_b64 s[4:5], s[6:7], s8
; GFX9-NEXT:    s_bfe_i64 s[4:5], s[4:5], 0x10000
; GFX9-NEXT:    v_mov_b32_e32 v0, s4
; GFX9-NEXT:    v_mov_b32_e32 v1, s5
; GFX9-NEXT:    buffer_store_dwordx2 v[0:1], off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_i1_to_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 9, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.W, KC0[3].Y, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T0.W, KC0[2].W, PV.W,
; EG-NEXT:     AND_INT * T1.W, KC0[3].Y, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT * T0.W, PS, PV.W, 0.0,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, 1,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     MOV * T0.Y, PV.X,
  %c = shl i64 %a, %b
  %shl = shl i64 %c, 63
  %ashr = ashr i64 %shl, 63
  store i64 %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_i8_to_i64:
; GCN: s_lshl_b64 [[VAL:s\[[0-9]+:[0-9]+\]]]
; GCN-DAG: s_bfe_i64 s[[[SLO:[0-9]+]]:[[SHI:[0-9]+]]], [[VAL]], 0x80000
; GCN-DAG: v_mov_b32_e32 v[[VLO:[0-9]+]], s[[SLO]]
; GCN-DAG: v_mov_b32_e32 v[[VHI:[0-9]+]], s[[SHI]]
; GCN: buffer_store_dwordx2 v[[[VLO]]:[[VHI]]]
define amdgpu_kernel void @sext_in_reg_i8_to_i64(ptr addrspace(1) %out, i64 %a, i64 %b) #0 {
; SI-LABEL: sext_in_reg_i8_to_i64:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x9
; SI-NEXT:    s_load_dword s0, s[0:1], 0xd
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_lshl_b64 s[0:1], s[6:7], s0
; SI-NEXT:    s_bfe_i64 s[0:1], s[0:1], 0x80000
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    v_mov_b32_e32 v0, s0
; SI-NEXT:    v_mov_b32_e32 v1, s1
; SI-NEXT:    buffer_store_dwordx2 v[0:1], off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_i8_to_i64:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x24
; GFX9-NEXT:    s_load_dword s8, s[0:1], 0x34
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s0, s4
; GFX9-NEXT:    s_mov_b32 s1, s5
; GFX9-NEXT:    s_lshl_b64 s[4:5], s[6:7], s8
; GFX9-NEXT:    s_bfe_i64 s[4:5], s[4:5], 0x80000
; GFX9-NEXT:    v_mov_b32_e32 v0, s4
; GFX9-NEXT:    v_mov_b32_e32 v1, s5
; GFX9-NEXT:    buffer_store_dwordx2 v[0:1], off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_i8_to_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 10, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.W, KC0[3].Y, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T0.W, KC0[2].W, PV.W,
; EG-NEXT:     AND_INT * T1.W, KC0[3].Y, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT * T0.W, PS, PV.W, 0.0,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    8(1.121039e-44), 2(2.802597e-45)
; EG-NEXT:     ASHR * T0.Y, PV.X, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
  %c = shl i64 %a, %b
  %shl = shl i64 %c, 56
  %ashr = ashr i64 %shl, 56
  store i64 %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_i16_to_i64:
; GCN: s_lshl_b64 [[VAL:s\[[0-9]+:[0-9]+\]]]
; GCN-DAG: s_bfe_i64 s[[[SLO:[0-9]+]]:[[SHI:[0-9]+]]], [[VAL]], 0x100000
; GCN-DAG: v_mov_b32_e32 v[[VLO:[0-9]+]], s[[SLO]]
; GCN-DAG: v_mov_b32_e32 v[[VHI:[0-9]+]], s[[SHI]]
; GCN: buffer_store_dwordx2 v[[[VLO]]:[[VHI]]]

define amdgpu_kernel void @sext_in_reg_i16_to_i64(ptr addrspace(1) %out, i64 %a, i64 %b) #0 {
; SI-LABEL: sext_in_reg_i16_to_i64:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x9
; SI-NEXT:    s_load_dword s0, s[0:1], 0xd
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_lshl_b64 s[0:1], s[6:7], s0
; SI-NEXT:    s_bfe_i64 s[0:1], s[0:1], 0x100000
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    v_mov_b32_e32 v0, s0
; SI-NEXT:    v_mov_b32_e32 v1, s1
; SI-NEXT:    buffer_store_dwordx2 v[0:1], off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_i16_to_i64:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x24
; GFX9-NEXT:    s_load_dword s8, s[0:1], 0x34
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s0, s4
; GFX9-NEXT:    s_mov_b32 s1, s5
; GFX9-NEXT:    s_lshl_b64 s[4:5], s[6:7], s8
; GFX9-NEXT:    s_bfe_i64 s[4:5], s[4:5], 0x100000
; GFX9-NEXT:    v_mov_b32_e32 v0, s4
; GFX9-NEXT:    v_mov_b32_e32 v1, s5
; GFX9-NEXT:    buffer_store_dwordx2 v[0:1], off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_i16_to_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 10, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.W, KC0[3].Y, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T0.W, KC0[2].W, PV.W,
; EG-NEXT:     AND_INT * T1.W, KC0[3].Y, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT * T0.W, PS, PV.W, 0.0,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    16(2.242078e-44), 2(2.802597e-45)
; EG-NEXT:     ASHR * T0.Y, PV.X, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
  %c = shl i64 %a, %b
  %shl = shl i64 %c, 48
  %ashr = ashr i64 %shl, 48
  store i64 %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_i32_to_i64:
; GCN: s_lshl_b64 [[VAL:s\[[0-9]+:[0-9]+\]]]
; GCN-DAG: s_bfe_i64 s[[[SLO:[0-9]+]]:[[SHI:[0-9]+]]], [[VAL]], 0x200000
; GCN-DAG: v_mov_b32_e32 v[[VLO:[0-9]+]], s[[SLO]]
; GCN-DAG: v_mov_b32_e32 v[[VHI:[0-9]+]], s[[SHI]]
; GCN: buffer_store_dwordx2 v[[[VLO]]:[[VHI]]]
define amdgpu_kernel void @sext_in_reg_i32_to_i64(ptr addrspace(1) %out, i64 %a, i64 %b) #0 {
; SI-LABEL: sext_in_reg_i32_to_i64:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x9
; SI-NEXT:    s_load_dword s0, s[0:1], 0xd
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_lshl_b64 s[0:1], s[6:7], s0
; SI-NEXT:    s_bfe_i64 s[0:1], s[0:1], 0x200000
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    v_mov_b32_e32 v0, s0
; SI-NEXT:    v_mov_b32_e32 v1, s1
; SI-NEXT:    buffer_store_dwordx2 v[0:1], off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_i32_to_i64:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x24
; GFX9-NEXT:    s_load_dword s8, s[0:1], 0x34
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s0, s4
; GFX9-NEXT:    s_mov_b32 s1, s5
; GFX9-NEXT:    s_lshl_b64 s[4:5], s[6:7], s8
; GFX9-NEXT:    s_bfe_i64 s[4:5], s[4:5], 0x200000
; GFX9-NEXT:    v_mov_b32_e32 v0, s4
; GFX9-NEXT:    v_mov_b32_e32 v1, s5
; GFX9-NEXT:    buffer_store_dwordx2 v[0:1], off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_i32_to_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 9, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     AND_INT * T0.W, KC0[3].Y, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T0.W, KC0[2].W, PV.W,
; EG-NEXT:     AND_INT * T1.W, KC0[3].Y, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT T0.X, PS, PV.W, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
; EG-NEXT:     ASHR * T0.Y, PV.X, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
  %c = shl i64 %a, %b
  %shl = shl i64 %c, 32
  %ashr = ashr i64 %shl, 32
  store i64 %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; This is broken on Evergreen for some reason related to the <1 x i64> kernel arguments.
; XFUNC-LABEL: {{^}}sext_in_reg_i8_to_v1i64:
; XGCN: s_bfe_i32 [[EXTRACT:s[0-9]+]], {{s[0-9]+}}, 524288
; XGCN: s_ashr_i32 {{v[0-9]+}}, [[EXTRACT]], 31
; XGCN: buffer_store_dword
; XEG: BFE_INT
; XEG: ASHR
; define amdgpu_kernel void @sext_in_reg_i8_to_v1i64(ptr addrspace(1) %out, <1 x i64> %a, <1 x i64> %b) #0 {
;   %c = add <1 x i64> %a, %b
;   %shl = shl <1 x i64> %c, <i64 56>
;   %ashr = ashr <1 x i64> %shl, <i64 56>
;   store <1 x i64> %ashr, ptr addrspace(1) %out, align 8
;   ret void
; }

; FUNC-LABEL: {{^}}v_sext_in_reg_i1_to_i64:
; SI: buffer_load_dwordx2
; SI: v_lshl_b64 v[[[VAL_LO:[0-9]+]]:[[VAL_HI:[0-9]+]]]

; GFX89: {{flat|global}}_load_dwordx2
; GFX89: v_lshlrev_b64 v[[[VAL_LO:[0-9]+]]:[[VAL_HI:[0-9]+]]]

; GCN: v_bfe_i32 v[[LO:[0-9]+]], v[[VAL_LO]], 0, 1
; GCN: v_ashrrev_i32_e32 v[[HI:[0-9]+]], 31, v[[LO]]

; SI: buffer_store_dwordx2 v[[[LO]]:[[HI]]]
; GFX89: {{flat|global}}_store_dwordx2 v{{.+}}, v[[[LO]]:[[HI]]]
define amdgpu_kernel void @v_sext_in_reg_i1_to_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, ptr addrspace(1) %bptr) #0 {
; SI-LABEL: v_sext_in_reg_i1_to_i64:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_mov_b32 s6, 0
; SI-NEXT:    v_lshlrev_b32_e32 v0, 3, v0
; SI-NEXT:    v_mov_b32_e32 v1, 0
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b64 s[4:5], s[2:3]
; SI-NEXT:    buffer_load_dwordx2 v[2:3], v[0:1], s[4:7], 0 addr64
; SI-NEXT:    s_mov_b64 s[2:3], s[6:7]
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_lshl_b64 v[2:3], v[2:3], v2
; SI-NEXT:    v_bfe_i32 v2, v2, 0, 1
; SI-NEXT:    v_ashrrev_i32_e32 v3, 31, v2
; SI-NEXT:    buffer_store_dwordx2 v[2:3], v[0:1], s[0:3], 0 addr64
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: v_sext_in_reg_i1_to_i64:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    v_lshlrev_b32_e32 v2, 3, v0
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    global_load_dwordx2 v[0:1], v2, s[2:3]
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_lshlrev_b64 v[0:1], v0, v[0:1]
; GFX9-NEXT:    v_bfe_i32 v0, v0, 0, 1
; GFX9-NEXT:    v_ashrrev_i32_e32 v1, 31, v0
; GFX9-NEXT:    global_store_dwordx2 v2, v[0:1], s[0:1]
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: v_sext_in_reg_i1_to_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 10, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT * T1.W, T0.X, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T1.W, T0.X, PV.W,
; EG-NEXT:     AND_INT * T2.W, T0.X, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT * T1.W, PS, PV.W, 0.0,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, 1,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:     LSHR T1.X, PV.W, literal.x,
; EG-NEXT:     MOV * T0.Y, PV.X,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %a.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %b.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %out.gep = getelementptr i64, ptr addrspace(1) %out, i32 %tid
  %a = load i64, ptr addrspace(1) %a.gep, align 8
  %b = load i64, ptr addrspace(1) %b.gep, align 8

  %c = shl i64 %a, %b
  %shl = shl i64 %c, 63
  %ashr = ashr i64 %shl, 63
  store i64 %ashr, ptr addrspace(1) %out.gep, align 8
  ret void
}

; FUNC-LABEL: {{^}}v_sext_in_reg_i8_to_i64:
; SI: buffer_load_dwordx2
; SI: v_lshl_b64 v[[[VAL_LO:[0-9]+]]:[[VAL_HI:[0-9]+]]]

; GFX89: {{flat|global}}_load_dwordx2
; GFX89: v_lshlrev_b64 v[[[VAL_LO:[0-9]+]]:[[VAL_HI:[0-9]+]]]

; GCN: v_bfe_i32 v[[LO:[0-9]+]], v[[VAL_LO]], 0, 8
; GCN: v_ashrrev_i32_e32 v[[HI:[0-9]+]], 31, v[[LO]]

; SI: buffer_store_dwordx2 v[[[LO]]:[[HI]]]
; GFX89: {{flat|global}}_store_dwordx2 v{{.+}}, v[[[LO]]:[[HI]]]
define amdgpu_kernel void @v_sext_in_reg_i8_to_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, ptr addrspace(1) %bptr) #0 {
; SI-LABEL: v_sext_in_reg_i8_to_i64:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_mov_b32 s6, 0
; SI-NEXT:    v_lshlrev_b32_e32 v0, 3, v0
; SI-NEXT:    v_mov_b32_e32 v1, 0
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b64 s[4:5], s[2:3]
; SI-NEXT:    buffer_load_dwordx2 v[2:3], v[0:1], s[4:7], 0 addr64
; SI-NEXT:    s_mov_b64 s[2:3], s[6:7]
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_lshl_b64 v[2:3], v[2:3], v2
; SI-NEXT:    v_bfe_i32 v2, v2, 0, 8
; SI-NEXT:    v_ashrrev_i32_e32 v3, 31, v2
; SI-NEXT:    buffer_store_dwordx2 v[2:3], v[0:1], s[0:3], 0 addr64
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: v_sext_in_reg_i8_to_i64:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    v_lshlrev_b32_e32 v2, 3, v0
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    global_load_dwordx2 v[0:1], v2, s[2:3]
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_lshlrev_b64 v[0:1], v0, v[0:1]
; GFX9-NEXT:    v_bfe_i32 v0, v0, 0, 8
; GFX9-NEXT:    v_ashrrev_i32_e32 v1, 31, v0
; GFX9-NEXT:    global_store_dwordx2 v2, v[0:1], s[0:1]
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: v_sext_in_reg_i8_to_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 11, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT * T1.W, T0.X, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T1.W, T0.X, PV.W,
; EG-NEXT:     AND_INT * T2.W, T0.X, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT * T1.W, PS, PV.W, 0.0,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     LSHR T1.X, PV.W, literal.x,
; EG-NEXT:     ASHR * T0.Y, PV.X, literal.y,
; EG-NEXT:    2(2.802597e-45), 31(4.344025e-44)
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %a.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %b.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %out.gep = getelementptr i64, ptr addrspace(1) %out, i32 %tid
  %a = load i64, ptr addrspace(1) %a.gep, align 8
  %b = load i64, ptr addrspace(1) %b.gep, align 8

  %c = shl i64 %a, %b
  %shl = shl i64 %c, 56
  %ashr = ashr i64 %shl, 56
  store i64 %ashr, ptr addrspace(1) %out.gep, align 8
  ret void
}

; FUNC-LABEL: {{^}}v_sext_in_reg_i16_to_i64:
; SI: buffer_load_dwordx2
; SI: v_lshl_b64 v[[[VAL_LO:[0-9]+]]:[[VAL_HI:[0-9]+]]]

; GFX89: {{flat|global}}_load_dwordx2
; GFX89: v_lshlrev_b64 v[[[VAL_LO:[0-9]+]]:[[VAL_HI:[0-9]+]]]

; GCN: v_bfe_i32 v[[LO:[0-9]+]], v[[VAL_LO]], 0, 16
; GCN: v_ashrrev_i32_e32 v[[HI:[0-9]+]], 31, v[[LO]]

; SI: buffer_store_dwordx2 v[[[LO]]:[[HI]]]
; GFX89: {{flat|global}}_store_dwordx2 v{{.+}}, v[[[LO]]:[[HI]]]
define amdgpu_kernel void @v_sext_in_reg_i16_to_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, ptr addrspace(1) %bptr) #0 {
; SI-LABEL: v_sext_in_reg_i16_to_i64:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_mov_b32 s6, 0
; SI-NEXT:    v_lshlrev_b32_e32 v0, 3, v0
; SI-NEXT:    v_mov_b32_e32 v1, 0
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b64 s[4:5], s[2:3]
; SI-NEXT:    buffer_load_dwordx2 v[2:3], v[0:1], s[4:7], 0 addr64
; SI-NEXT:    s_mov_b64 s[2:3], s[6:7]
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_lshl_b64 v[2:3], v[2:3], v2
; SI-NEXT:    v_bfe_i32 v2, v2, 0, 16
; SI-NEXT:    v_ashrrev_i32_e32 v3, 31, v2
; SI-NEXT:    buffer_store_dwordx2 v[2:3], v[0:1], s[0:3], 0 addr64
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: v_sext_in_reg_i16_to_i64:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    v_lshlrev_b32_e32 v2, 3, v0
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    global_load_dwordx2 v[0:1], v2, s[2:3]
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_lshlrev_b64 v[0:1], v0, v[0:1]
; GFX9-NEXT:    v_bfe_i32 v0, v0, 0, 16
; GFX9-NEXT:    v_ashrrev_i32_e32 v1, 31, v0
; GFX9-NEXT:    global_store_dwordx2 v2, v[0:1], s[0:1]
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: v_sext_in_reg_i16_to_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 11, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT * T1.W, T0.X, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T1.W, T0.X, PV.W,
; EG-NEXT:     AND_INT * T2.W, T0.X, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT * T1.W, PS, PV.W, 0.0,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:    16(2.242078e-44), 0(0.000000e+00)
; EG-NEXT:     LSHR T1.X, PV.W, literal.x,
; EG-NEXT:     ASHR * T0.Y, PV.X, literal.y,
; EG-NEXT:    2(2.802597e-45), 31(4.344025e-44)
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %a.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %b.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %out.gep = getelementptr i64, ptr addrspace(1) %out, i32 %tid
  %a = load i64, ptr addrspace(1) %a.gep, align 8
  %b = load i64, ptr addrspace(1) %b.gep, align 8

  %c = shl i64 %a, %b
  %shl = shl i64 %c, 48
  %ashr = ashr i64 %shl, 48
  store i64 %ashr, ptr addrspace(1) %out.gep, align 8
  ret void
}

; FUNC-LABEL: {{^}}v_sext_in_reg_i32_to_i64:
; SI: buffer_load_dwordx2
; SI: v_lshl_b64 v[[[LO:[0-9]+]]:[[HI:[0-9]+]]],

; GFX89: {{flat|global}}_load_dwordx2
; GFX89: v_lshlrev_b64 v[[[LO:[0-9]+]]:[[HI:[0-9]+]]],

; GCN: v_ashrrev_i32_e32 v[[SHR:[0-9]+]], 31, v[[LO]]
; GFX89: {{flat|global}}_store_dwordx2 v{{.+}}, v[[[LO]]:[[SHR]]]
define amdgpu_kernel void @v_sext_in_reg_i32_to_i64(ptr addrspace(1) %out, ptr addrspace(1) %aptr, ptr addrspace(1) %bptr) #0 {
; SI-LABEL: v_sext_in_reg_i32_to_i64:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_mov_b32 s6, 0
; SI-NEXT:    v_lshlrev_b32_e32 v0, 3, v0
; SI-NEXT:    v_mov_b32_e32 v1, 0
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b64 s[4:5], s[2:3]
; SI-NEXT:    buffer_load_dwordx2 v[2:3], v[0:1], s[4:7], 0 addr64
; SI-NEXT:    s_mov_b64 s[2:3], s[6:7]
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_lshl_b64 v[2:3], v[2:3], v2
; SI-NEXT:    v_ashrrev_i32_e32 v3, 31, v2
; SI-NEXT:    buffer_store_dwordx2 v[2:3], v[0:1], s[0:3], 0 addr64
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: v_sext_in_reg_i32_to_i64:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    v_lshlrev_b32_e32 v2, 3, v0
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    global_load_dwordx2 v[0:1], v2, s[2:3]
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_lshlrev_b64 v[0:1], v0, v[0:1]
; GFX9-NEXT:    v_ashrrev_i32_e32 v1, 31, v0
; GFX9-NEXT:    global_store_dwordx2 v2, v[0:1], s[0:1]
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: v_sext_in_reg_i32_to_i64:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 9, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT * T1.W, T0.X, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T1.W, T0.X, PV.W,
; EG-NEXT:     AND_INT * T2.W, T0.X, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT T0.X, PS, PV.W, 0.0,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:     LSHR T1.X, PV.W, literal.x,
; EG-NEXT:     ASHR * T0.Y, PV.X, literal.y,
; EG-NEXT:    2(2.802597e-45), 31(4.344025e-44)
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %a.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %b.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %out.gep = getelementptr i64, ptr addrspace(1) %out, i32 %tid
  %a = load i64, ptr addrspace(1) %a.gep, align 8
  %b = load i64, ptr addrspace(1) %b.gep, align 8

  %c = shl i64 %a, %b
  %shl = shl i64 %c, 32
  %ashr = ashr i64 %shl, 32
  store i64 %ashr, ptr addrspace(1) %out.gep, align 8
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_i1_in_i32_other_amount:
; GCN-NOT: s_lshl
; GCN-NOT: s_ashr
; GCN: s_bfe_i32 {{s[0-9]+}}, {{s[0-9]+}}, 0x190001

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+\.[XYZW]]], [[ADDR:T[0-9]+.[XYZW]]]
; EG-NOT: BFE
; EG: ADD_INT
; EG: LSHL
; EG: ASHR [[RES]]
; EG: LSHR {{\*?}} [[ADDR]]
define amdgpu_kernel void @sext_in_reg_i1_in_i32_other_amount(ptr addrspace(1) %out, i32 %a, i32 %b) #0 {
; SI-LABEL: sext_in_reg_i1_in_i32_other_amount:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s2, s3
; SI-NEXT:    s_bfe_i32 s2, s2, 0x190001
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    s_mov_b32 s4, s0
; SI-NEXT:    s_mov_b32 s5, s1
; SI-NEXT:    v_mov_b32_e32 v0, s2
; SI-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX89-LABEL: sext_in_reg_i1_in_i32_other_amount:
; GFX89:       ; %bb.0:
; GFX89-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX89-NEXT:    s_mov_b32 s7, 0xf000
; GFX89-NEXT:    s_mov_b32 s6, -1
; GFX89-NEXT:    s_waitcnt lgkmcnt(0)
; GFX89-NEXT:    s_mov_b32 s4, s0
; GFX89-NEXT:    s_add_i32 s0, s2, s3
; GFX89-NEXT:    s_bfe_i32 s0, s0, 0x190001
; GFX89-NEXT:    s_mov_b32 s5, s1
; GFX89-NEXT:    v_mov_b32_e32 v0, s0
; GFX89-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX89-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_i1_in_i32_other_amount:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s4, s0
; GFX9-NEXT:    s_add_i32 s0, s2, s3
; GFX9-NEXT:    s_bfe_i32 s0, s0, 0x190001
; GFX9-NEXT:    s_mov_b32 s5, s1
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_i1_in_i32_other_amount:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 5, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.X, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Z, KC0[2].W,
; EG-NEXT:     LSHL * T0.W, PV.W, literal.x,
; EG-NEXT:    6(8.407791e-45), 0(0.000000e+00)
; EG-NEXT:     ASHR T0.X, PV.W, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    7(9.809089e-45), 2(2.802597e-45)
  %c = add i32 %a, %b
  %x = shl i32 %c, 6
  %y = ashr i32 %x, 7
  store i32 %y, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v2i1_in_v2i32_other_amount:
; GCN-NOT: s_lshl
; GCN-NOT: s_ashr
; GCN-DAG: s_bfe_i32 {{s[0-9]+}}, {{s[0-9]+}}, 0x190001
; GCN-DAG: s_bfe_i32 {{s[0-9]+}}, {{s[0-9]+}}, 0x190001
; GCN: s_endpgm

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+]]{{\.[XYZW][XYZW]}}, [[ADDR:T[0-9]+.[XYZW]]]
; EG-NOT: BFE
; EG: ADD_INT
; EG: LSHL
; EG: ASHR [[RES]]
; EG: LSHL
; EG: ASHR [[RES]]
; EG: LSHR {{\*?}} [[ADDR]]
define amdgpu_kernel void @sext_in_reg_v2i1_in_v2i32_other_amount(ptr addrspace(1) %out, <2 x i32> %a, <2 x i32> %b) #0 {
; SI-LABEL: sext_in_reg_v2i1_in_v2i32_other_amount:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s4, s6
; SI-NEXT:    s_add_i32 s4, s5, s7
; SI-NEXT:    s_bfe_i32 s4, s4, 0x190001
; SI-NEXT:    s_bfe_i32 s5, s2, 0x190001
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s5
; SI-NEXT:    v_mov_b32_e32 v1, s4
; SI-NEXT:    buffer_store_dwordx2 v[0:1], off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v2i1_in_v2i32_other_amount:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s11, 0xf000
; GFX9-NEXT:    s_mov_b32 s10, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_add_i32 s0, s4, s6
; GFX9-NEXT:    s_add_i32 s1, s5, s7
; GFX9-NEXT:    s_bfe_i32 s1, s1, 0x190001
; GFX9-NEXT:    s_bfe_i32 s0, s0, 0x190001
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    v_mov_b32_e32 v1, s1
; GFX9-NEXT:    buffer_store_dwordx2 v[0:1], off, s[8:11], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v2i1_in_v2i32_other_amount:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 9, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[3].X, KC0[3].Z,
; EG-NEXT:     ADD_INT T1.W, KC0[2].W, KC0[3].Y,
; EG-NEXT:     LSHL * T0.W, PV.W, literal.x,
; EG-NEXT:    6(8.407791e-45), 0(0.000000e+00)
; EG-NEXT:     ASHR T0.Y, PS, literal.x,
; EG-NEXT:     LSHL * T0.W, PV.W, literal.y,
; EG-NEXT:    7(9.809089e-45), 6(8.407791e-45)
; EG-NEXT:     ASHR T0.X, PV.W, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    7(9.809089e-45), 2(2.802597e-45)
  %c = add <2 x i32> %a, %b
  %x = shl <2 x i32> %c, <i32 6, i32 6>
  %y = ashr <2 x i32> %x, <i32 7, i32 7>
  store <2 x i32> %y, ptr addrspace(1) %out
  ret void
}


; FUNC-LABEL: {{^}}sext_in_reg_v2i1_to_v2i32:
; GCN: s_bfe_i32 {{s[0-9]+}}, {{s[0-9]+}}, 0x10000
; GCN: s_bfe_i32 {{s[0-9]+}}, {{s[0-9]+}}, 0x10000
; GCN: buffer_store_dwordx2

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+]]{{\.[XYZW][XYZW]}}, [[ADDR:T[0-9]+.[XYZW]]]
; EG: BFE_INT [[RES]]
; EG: BFE_INT [[RES]]
; EG: LSHR {{\*?}} [[ADDR]]
define amdgpu_kernel void @sext_in_reg_v2i1_to_v2i32(ptr addrspace(1) %out, <2 x i32> %a, <2 x i32> %b) #0 {
; SI-LABEL: sext_in_reg_v2i1_to_v2i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s4, s6
; SI-NEXT:    s_add_i32 s4, s5, s7
; SI-NEXT:    s_bfe_i32 s4, s4, 0x10000
; SI-NEXT:    s_bfe_i32 s5, s2, 0x10000
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s5
; SI-NEXT:    v_mov_b32_e32 v1, s4
; SI-NEXT:    buffer_store_dwordx2 v[0:1], off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v2i1_to_v2i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s11, 0xf000
; GFX9-NEXT:    s_mov_b32 s10, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_add_i32 s0, s4, s6
; GFX9-NEXT:    s_add_i32 s1, s5, s7
; GFX9-NEXT:    s_bfe_i32 s1, s1, 0x10000
; GFX9-NEXT:    s_bfe_i32 s0, s0, 0x10000
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    v_mov_b32_e32 v1, s1
; GFX9-NEXT:    buffer_store_dwordx2 v[0:1], off, s[8:11], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v2i1_to_v2i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 5, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[3].X, KC0[3].Z,
; EG-NEXT:     BFE_INT T0.Y, PV.W, 0.0, 1,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].W, KC0[3].Y,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, 1,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %c = add <2 x i32> %a, %b ; add to prevent folding into extload
  %shl = shl <2 x i32> %c, <i32 31, i32 31>
  %ashr = ashr <2 x i32> %shl, <i32 31, i32 31>
  store <2 x i32> %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v4i1_to_v4i32:
; GCN: s_bfe_i32 {{s[0-9]+}}, {{s[0-9]+}}, 0x10000
; GCN: s_bfe_i32 {{s[0-9]+}}, {{s[0-9]+}}, 0x10000
; GCN: s_bfe_i32 {{s[0-9]+}}, {{s[0-9]+}}, 0x10000
; GCN: s_bfe_i32 {{s[0-9]+}}, {{s[0-9]+}}, 0x10000
; GCN: buffer_store_dwordx4

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+]]{{\.[XYZW][XYZW][XYZW][XYZW]}}, [[ADDR:T[0-9]+.[XYZW]]]
; EG: BFE_INT [[RES]]
; EG: BFE_INT [[RES]]
; EG: BFE_INT [[RES]]
; EG: BFE_INT [[RES]]
; EG: LSHR {{\*?}} [[ADDR]]
define amdgpu_kernel void @sext_in_reg_v4i1_to_v4i32(ptr addrspace(1) %out, <4 x i32> %a, <4 x i32> %b) #0 {
; SI-LABEL: sext_in_reg_v4i1_to_v4i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx8 s[4:11], s[0:1], 0xd
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s4, s8
; SI-NEXT:    s_add_i32 s4, s5, s9
; SI-NEXT:    s_add_i32 s5, s6, s10
; SI-NEXT:    s_add_i32 s6, s7, s11
; SI-NEXT:    s_bfe_i32 s6, s6, 0x10000
; SI-NEXT:    s_bfe_i32 s5, s5, 0x10000
; SI-NEXT:    s_bfe_i32 s4, s4, 0x10000
; SI-NEXT:    s_bfe_i32 s7, s2, 0x10000
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s7
; SI-NEXT:    v_mov_b32_e32 v1, s4
; SI-NEXT:    v_mov_b32_e32 v2, s5
; SI-NEXT:    v_mov_b32_e32 v3, s6
; SI-NEXT:    buffer_store_dwordx4 v[0:3], off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v4i1_to_v4i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx8 s[4:11], s[0:1], 0x34
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_add_i32 s4, s4, s8
; GFX9-NEXT:    s_add_i32 s5, s5, s9
; GFX9-NEXT:    s_add_i32 s6, s6, s10
; GFX9-NEXT:    s_add_i32 s7, s7, s11
; GFX9-NEXT:    s_bfe_i32 s7, s7, 0x10000
; GFX9-NEXT:    s_bfe_i32 s6, s6, 0x10000
; GFX9-NEXT:    s_bfe_i32 s5, s5, 0x10000
; GFX9-NEXT:    s_bfe_i32 s4, s4, 0x10000
; GFX9-NEXT:    v_mov_b32_e32 v0, s4
; GFX9-NEXT:    v_mov_b32_e32 v1, s5
; GFX9-NEXT:    v_mov_b32_e32 v2, s6
; GFX9-NEXT:    v_mov_b32_e32 v3, s7
; GFX9-NEXT:    buffer_store_dwordx4 v[0:3], off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v4i1_to_v4i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 9, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XYZW, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[4].X, KC0[5].X,
; EG-NEXT:     BFE_INT T0.W, PV.W, 0.0, 1,
; EG-NEXT:     ADD_INT * T1.W, KC0[3].W, KC0[4].W,
; EG-NEXT:     BFE_INT T0.Z, PS, 0.0, 1,
; EG-NEXT:     ADD_INT * T1.W, KC0[3].Z, KC0[4].Z,
; EG-NEXT:     BFE_INT T0.Y, PV.W, 0.0, 1,
; EG-NEXT:     ADD_INT * T1.W, KC0[3].Y, KC0[4].Y,
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, 1,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %c = add <4 x i32> %a, %b ; add to prevent folding into extload
  %shl = shl <4 x i32> %c, <i32 31, i32 31, i32 31, i32 31>
  %ashr = ashr <4 x i32> %shl, <i32 31, i32 31, i32 31, i32 31>
  store <4 x i32> %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v2i8_to_v2i32:
; GCN: s_sext_i32_i8 {{s[0-9]+}}, {{s[0-9]+}}
; GCN: s_sext_i32_i8 {{s[0-9]+}}, {{s[0-9]+}}
; GCN: buffer_store_dwordx2

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+]]{{\.[XYZW][XYZW]}}, [[ADDR:T[0-9]+.[XYZW]]]
; EG: BFE_INT [[RES]]
; EG: BFE_INT [[RES]]
; EG: LSHR {{\*?}} [[ADDR]]
define amdgpu_kernel void @sext_in_reg_v2i8_to_v2i32(ptr addrspace(1) %out, <2 x i32> %a, <2 x i32> %b) #0 {
; SI-LABEL: sext_in_reg_v2i8_to_v2i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s4, s6
; SI-NEXT:    s_add_i32 s4, s5, s7
; SI-NEXT:    s_sext_i32_i8 s4, s4
; SI-NEXT:    s_sext_i32_i8 s5, s2
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s5
; SI-NEXT:    v_mov_b32_e32 v1, s4
; SI-NEXT:    buffer_store_dwordx2 v[0:1], off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v2i8_to_v2i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s11, 0xf000
; GFX9-NEXT:    s_mov_b32 s10, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_add_i32 s0, s4, s6
; GFX9-NEXT:    s_add_i32 s1, s5, s7
; GFX9-NEXT:    s_sext_i32_i8 s1, s1
; GFX9-NEXT:    s_sext_i32_i8 s0, s0
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    v_mov_b32_e32 v1, s1
; GFX9-NEXT:    buffer_store_dwordx2 v[0:1], off, s[8:11], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v2i8_to_v2i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 6, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[3].X, KC0[3].Z,
; EG-NEXT:     BFE_INT T0.Y, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].W, KC0[3].Y,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    8(1.121039e-44), 2(2.802597e-45)
  %c = add <2 x i32> %a, %b ; add to prevent folding into extload
  %shl = shl <2 x i32> %c, <i32 24, i32 24>
  %ashr = ashr <2 x i32> %shl, <i32 24, i32 24>
  store <2 x i32> %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v4i8_to_v4i32:
; GCN: s_sext_i32_i8 {{s[0-9]+}}, {{s[0-9]+}}
; GCN: s_sext_i32_i8 {{s[0-9]+}}, {{s[0-9]+}}
; GCN: s_sext_i32_i8 {{s[0-9]+}}, {{s[0-9]+}}
; GCN: s_sext_i32_i8 {{s[0-9]+}}, {{s[0-9]+}}
; GCN: buffer_store_dwordx4

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+]]{{\.[XYZW][XYZW][XYZW][XYZW]}}, [[ADDR:T[0-9]+.[XYZW]]]
; EG: BFE_INT [[RES]]
; EG: BFE_INT [[RES]]
; EG: BFE_INT [[RES]]
; EG: BFE_INT [[RES]]
; EG: LSHR {{\*?}} [[ADDR]]
define amdgpu_kernel void @sext_in_reg_v4i8_to_v4i32(ptr addrspace(1) %out, <4 x i32> %a, <4 x i32> %b) #0 {
; SI-LABEL: sext_in_reg_v4i8_to_v4i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx8 s[4:11], s[0:1], 0xd
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s4, s8
; SI-NEXT:    s_add_i32 s4, s5, s9
; SI-NEXT:    s_add_i32 s5, s6, s10
; SI-NEXT:    s_add_i32 s6, s7, s11
; SI-NEXT:    s_sext_i32_i8 s6, s6
; SI-NEXT:    s_sext_i32_i8 s5, s5
; SI-NEXT:    s_sext_i32_i8 s4, s4
; SI-NEXT:    s_sext_i32_i8 s7, s2
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s7
; SI-NEXT:    v_mov_b32_e32 v1, s4
; SI-NEXT:    v_mov_b32_e32 v2, s5
; SI-NEXT:    v_mov_b32_e32 v3, s6
; SI-NEXT:    buffer_store_dwordx4 v[0:3], off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v4i8_to_v4i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx8 s[4:11], s[0:1], 0x34
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_add_i32 s4, s4, s8
; GFX9-NEXT:    s_add_i32 s5, s5, s9
; GFX9-NEXT:    s_add_i32 s6, s6, s10
; GFX9-NEXT:    s_add_i32 s7, s7, s11
; GFX9-NEXT:    s_sext_i32_i8 s7, s7
; GFX9-NEXT:    s_sext_i32_i8 s6, s6
; GFX9-NEXT:    s_sext_i32_i8 s5, s5
; GFX9-NEXT:    s_sext_i32_i8 s4, s4
; GFX9-NEXT:    v_mov_b32_e32 v0, s4
; GFX9-NEXT:    v_mov_b32_e32 v1, s5
; GFX9-NEXT:    v_mov_b32_e32 v2, s6
; GFX9-NEXT:    v_mov_b32_e32 v3, s7
; GFX9-NEXT:    buffer_store_dwordx4 v[0:3], off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v4i8_to_v4i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 12, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XYZW, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[4].X, KC0[5].X,
; EG-NEXT:     BFE_INT T0.W, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T1.W, KC0[3].W, KC0[4].W,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.Z, PS, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T1.W, KC0[3].Z, KC0[4].Z,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.Y, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T1.W, KC0[3].Y, KC0[4].Y,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    8(1.121039e-44), 2(2.802597e-45)
  %c = add <4 x i32> %a, %b ; add to prevent folding into extload
  %shl = shl <4 x i32> %c, <i32 24, i32 24, i32 24, i32 24>
  %ashr = ashr <4 x i32> %shl, <i32 24, i32 24, i32 24, i32 24>
  store <4 x i32> %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v2i16_to_v2i32:
; GCN: s_sext_i32_i16 {{s[0-9]+}}, {{s[0-9]+}}
; GCN: s_sext_i32_i16 {{s[0-9]+}}, {{s[0-9]+}}
; GCN: buffer_store_dwordx2

; EG: MEM_{{.*}} STORE_{{.*}} [[RES:T[0-9]+]]{{\.[XYZW][XYZW]}}, [[ADDR:T[0-9]+.[XYZW]]]
; EG: BFE_INT [[RES]]
; EG: BFE_INT [[RES]]
; EG: LSHR {{\*?}} [[ADDR]]
define amdgpu_kernel void @sext_in_reg_v2i16_to_v2i32(ptr addrspace(1) %out, <2 x i32> %a, <2 x i32> %b) #0 {
; SI-LABEL: sext_in_reg_v2i16_to_v2i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_add_i32 s2, s4, s6
; SI-NEXT:    s_add_i32 s4, s5, s7
; SI-NEXT:    s_sext_i32_i16 s4, s4
; SI-NEXT:    s_sext_i32_i16 s5, s2
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s5
; SI-NEXT:    v_mov_b32_e32 v1, s4
; SI-NEXT:    buffer_store_dwordx2 v[0:1], off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v2i16_to_v2i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s11, 0xf000
; GFX9-NEXT:    s_mov_b32 s10, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_add_i32 s0, s4, s6
; GFX9-NEXT:    s_add_i32 s1, s5, s7
; GFX9-NEXT:    s_sext_i32_i16 s1, s1
; GFX9-NEXT:    s_sext_i32_i16 s0, s0
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    v_mov_b32_e32 v1, s1
; GFX9-NEXT:    buffer_store_dwordx2 v[0:1], off, s[8:11], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v2i16_to_v2i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 6, @4, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    ALU clause starting at 4:
; EG-NEXT:     ADD_INT * T0.W, KC0[3].X, KC0[3].Z,
; EG-NEXT:     BFE_INT T0.Y, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].W, KC0[3].Y,
; EG-NEXT:    16(2.242078e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    16(2.242078e-44), 2(2.802597e-45)
  %c = add <2 x i32> %a, %b ; add to prevent folding into extload
  %shl = shl <2 x i32> %c, <i32 16, i32 16>
  %ashr = ashr <2 x i32> %shl, <i32 16, i32 16>
  store <2 x i32> %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}testcase:
define amdgpu_kernel void @testcase(ptr addrspace(1) %out, i8 %a) #0 {
; SI-LABEL: testcase:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dword s2, s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_sext_i32_i8 s4, s2
; SI-NEXT:    s_bfe_i32 s5, s2, 0x10000
; SI-NEXT:    s_max_i32 s4, s4, 0
; SI-NEXT:    s_and_b32 s2, s5, s2
; SI-NEXT:    s_xor_b32 s4, s4, s2
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_byte v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: testcase:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dword s2, s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[4:5], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_sext_i32_i8 s0, s2
; GFX9-NEXT:    s_max_i32 s0, s0, 0
; GFX9-NEXT:    s_bitcmp1_b32 s2, 0
; GFX9-NEXT:    s_cselect_b32 s1, s2, 0
; GFX9-NEXT:    s_xor_b32 s0, s0, s1
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_byte v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: testcase:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @8, KC0[], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 17, @9, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT MSKOR T0.XW, T1.X
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_8 T0.X, T0.X, 40, #3
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     MOV * T0.X, 0.0,
; EG-NEXT:    ALU clause starting at 9:
; EG-NEXT:     BFE_INT T0.Z, T0.X, 0.0, literal.x,
; EG-NEXT:     BFE_INT * T0.W, T0.X, 0.0, 1,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.W, PV.W, T0.X,
; EG-NEXT:     MAX_INT * T1.W, PV.Z, 0.0,
; EG-NEXT:     AND_INT T2.W, KC0[2].Y, literal.x,
; EG-NEXT:     XOR_INT * T0.W, PS, PV.W,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.W, PS, literal.x,
; EG-NEXT:     LSHL * T1.W, PV.W, literal.y,
; EG-NEXT:    255(3.573311e-43), 3(4.203895e-45)
; EG-NEXT:     LSHL T0.X, PV.W, PS,
; EG-NEXT:     LSHL * T0.W, literal.x, PS,
; EG-NEXT:    255(3.573311e-43), 0(0.000000e+00)
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     MOV * T0.Z, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and_a_1 = and i8 %a, 1
  %cmp_eq = icmp eq i8 %and_a_1, 0
  %cmp_slt = icmp slt i8 %a, 0
  %sel0 = select i1 %cmp_slt, i8 0, i8 %a
  %sel1 = select i1 %cmp_eq, i8 0, i8 %a
  %xor = xor i8 %sel0, %sel1
  store i8 %xor, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}testcase_3:
define amdgpu_kernel void @testcase_3(ptr addrspace(1) %out, i8 %a) #0 {
; SI-LABEL: testcase_3:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dword s2, s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_sext_i32_i8 s4, s2
; SI-NEXT:    s_bfe_i32 s5, s2, 0x10000
; SI-NEXT:    s_max_i32 s4, s4, 0
; SI-NEXT:    s_and_b32 s2, s5, s2
; SI-NEXT:    s_xor_b32 s4, s4, s2
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_byte v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: testcase_3:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dword s2, s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[4:5], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_sext_i32_i8 s0, s2
; GFX9-NEXT:    s_max_i32 s0, s0, 0
; GFX9-NEXT:    s_bitcmp1_b32 s2, 0
; GFX9-NEXT:    s_cselect_b32 s1, s2, 0
; GFX9-NEXT:    s_xor_b32 s0, s0, s1
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_byte v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: testcase_3:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @8, KC0[], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 17, @9, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT MSKOR T0.XW, T1.X
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_8 T0.X, T0.X, 40, #3
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     MOV * T0.X, 0.0,
; EG-NEXT:    ALU clause starting at 9:
; EG-NEXT:     BFE_INT T0.Z, T0.X, 0.0, literal.x,
; EG-NEXT:     BFE_INT * T0.W, T0.X, 0.0, 1,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.W, PV.W, T0.X,
; EG-NEXT:     MAX_INT * T1.W, PV.Z, 0.0,
; EG-NEXT:     AND_INT T2.W, KC0[2].Y, literal.x,
; EG-NEXT:     XOR_INT * T0.W, PS, PV.W,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.W, PS, literal.x,
; EG-NEXT:     LSHL * T1.W, PV.W, literal.y,
; EG-NEXT:    255(3.573311e-43), 3(4.203895e-45)
; EG-NEXT:     LSHL T0.X, PV.W, PS,
; EG-NEXT:     LSHL * T0.W, literal.x, PS,
; EG-NEXT:    255(3.573311e-43), 0(0.000000e+00)
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     MOV * T0.Z, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %and_a_1 = and i8 %a, 1
  %cmp_eq = icmp eq i8 %and_a_1, 0
  %cmp_slt = icmp slt i8 %a, 0
  %sel0 = select i1 %cmp_slt, i8 0, i8 %a
  %sel1 = select i1 %cmp_eq, i8 0, i8 %a
  %xor = xor i8 %sel0, %sel1
  store i8 %xor, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}vgpr_sext_in_reg_v4i8_to_v4i32:
; GCN: v_bfe_i32 [[EXTRACT:v[0-9]+]], {{v[0-9]+}}, 0, 8
; GCN: v_bfe_i32 [[EXTRACT:v[0-9]+]], {{v[0-9]+}}, 0, 8
; GCN: v_bfe_i32 [[EXTRACT:v[0-9]+]], {{v[0-9]+}}, 0, 8
; GCN: v_bfe_i32 [[EXTRACT:v[0-9]+]], {{v[0-9]+}}, 0, 8
define amdgpu_kernel void @vgpr_sext_in_reg_v4i8_to_v4i32(ptr addrspace(1) %out, ptr addrspace(1) %a, ptr addrspace(1) %b) #0 {
; SI-LABEL: vgpr_sext_in_reg_v4i8_to_v4i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x9
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0xd
; SI-NEXT:    s_mov_b32 s11, 0xf000
; SI-NEXT:    s_mov_b32 s10, -1
; SI-NEXT:    s_mov_b32 s14, s10
; SI-NEXT:    s_mov_b32 s15, s11
; SI-NEXT:    s_mov_b32 s2, s10
; SI-NEXT:    s_mov_b32 s3, s11
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b32 s12, s6
; SI-NEXT:    s_mov_b32 s13, s7
; SI-NEXT:    buffer_load_dwordx4 v[0:3], off, s[12:15], 0
; SI-NEXT:    buffer_load_dwordx4 v[4:7], off, s[0:3], 0
; SI-NEXT:    s_mov_b32 s8, s4
; SI-NEXT:    s_mov_b32 s9, s5
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_add_i32_e32 v0, vcc, v0, v4
; SI-NEXT:    v_add_i32_e32 v1, vcc, v1, v5
; SI-NEXT:    v_add_i32_e32 v2, vcc, v2, v6
; SI-NEXT:    v_add_i32_e32 v3, vcc, v3, v7
; SI-NEXT:    v_bfe_i32 v3, v3, 0, 8
; SI-NEXT:    v_bfe_i32 v2, v2, 0, 8
; SI-NEXT:    v_bfe_i32 v1, v1, 0, 8
; SI-NEXT:    v_bfe_i32 v0, v0, 0, 8
; SI-NEXT:    buffer_store_dwordx4 v[0:3], off, s[8:11], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: vgpr_sext_in_reg_v4i8_to_v4i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x24
; GFX9-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0x34
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_mov_b32 s10, s2
; GFX9-NEXT:    s_mov_b32 s11, s3
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s12, s6
; GFX9-NEXT:    s_mov_b32 s13, s7
; GFX9-NEXT:    s_mov_b32 s14, s2
; GFX9-NEXT:    s_mov_b32 s15, s3
; GFX9-NEXT:    buffer_load_dwordx4 v[0:3], off, s[8:11], 0
; GFX9-NEXT:    buffer_load_dwordx4 v[4:7], off, s[12:15], 0
; GFX9-NEXT:    s_mov_b32 s0, s4
; GFX9-NEXT:    s_mov_b32 s1, s5
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_add_u32_e32 v0, v4, v0
; GFX9-NEXT:    v_add_u32_e32 v1, v5, v1
; GFX9-NEXT:    v_add_u32_e32 v2, v6, v2
; GFX9-NEXT:    v_add_u32_e32 v3, v7, v3
; GFX9-NEXT:    v_bfe_i32 v3, v3, 0, 8
; GFX9-NEXT:    v_bfe_i32 v2, v2, 0, 8
; GFX9-NEXT:    v_bfe_i32 v1, v1, 0, 8
; GFX9-NEXT:    v_bfe_i32 v0, v0, 0, 8
; GFX9-NEXT:    buffer_store_dwordx4 v[0:3], off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: vgpr_sext_in_reg_v4i8_to_v4i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 1, @10, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 1 @6
; EG-NEXT:    ALU 12, @12, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XYZW, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_128 T1.XYZW, T1.X, 0, #1
; EG-NEXT:     VTX_READ_128 T0.XYZW, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 10:
; EG-NEXT:     MOV T0.X, KC0[2].Z,
; EG-NEXT:     MOV * T1.X, KC0[2].W,
; EG-NEXT:    ALU clause starting at 12:
; EG-NEXT:     ADD_INT * T0.W, T0.W, T1.W,
; EG-NEXT:     BFE_INT T0.W, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T1.W, T0.Z, T1.Z,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.Z, PS, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T1.W, T0.Y, T1.Y,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.Y, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T1.W, T0.X, T1.X,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    8(1.121039e-44), 2(2.802597e-45)
  %loada = load <4 x i32>, ptr addrspace(1) %a, align 16
  %loadb = load <4 x i32>, ptr addrspace(1) %b, align 16
  %c = add <4 x i32> %loada, %loadb ; add to prevent folding into extload
  %shl = shl <4 x i32> %c, <i32 24, i32 24, i32 24, i32 24>
  %ashr = ashr <4 x i32> %shl, <i32 24, i32 24, i32 24, i32 24>
  store <4 x i32> %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}vgpr_sext_in_reg_v4i16_to_v4i32:
; GCN: v_bfe_i32 [[EXTRACT:v[0-9]+]], {{v[0-9]+}}, 0, 16
; GCN: v_bfe_i32 [[EXTRACT:v[0-9]+]], {{v[0-9]+}}, 0, 16
define amdgpu_kernel void @vgpr_sext_in_reg_v4i16_to_v4i32(ptr addrspace(1) %out, ptr addrspace(1) %a, ptr addrspace(1) %b) #0 {
; SI-LABEL: vgpr_sext_in_reg_v4i16_to_v4i32:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x9
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0xd
; SI-NEXT:    s_mov_b32 s11, 0xf000
; SI-NEXT:    s_mov_b32 s10, -1
; SI-NEXT:    s_mov_b32 s14, s10
; SI-NEXT:    s_mov_b32 s15, s11
; SI-NEXT:    s_mov_b32 s2, s10
; SI-NEXT:    s_mov_b32 s3, s11
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b32 s12, s6
; SI-NEXT:    s_mov_b32 s13, s7
; SI-NEXT:    buffer_load_dwordx4 v[0:3], off, s[12:15], 0
; SI-NEXT:    buffer_load_dwordx4 v[4:7], off, s[0:3], 0
; SI-NEXT:    s_mov_b32 s8, s4
; SI-NEXT:    s_mov_b32 s9, s5
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_add_i32_e32 v0, vcc, v0, v4
; SI-NEXT:    v_add_i32_e32 v1, vcc, v1, v5
; SI-NEXT:    v_add_i32_e32 v2, vcc, v2, v6
; SI-NEXT:    v_add_i32_e32 v3, vcc, v3, v7
; SI-NEXT:    v_bfe_i32 v3, v3, 0, 16
; SI-NEXT:    v_bfe_i32 v2, v2, 0, 16
; SI-NEXT:    v_bfe_i32 v1, v1, 0, 16
; SI-NEXT:    v_bfe_i32 v0, v0, 0, 16
; SI-NEXT:    buffer_store_dwordx4 v[0:3], off, s[8:11], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: vgpr_sext_in_reg_v4i16_to_v4i32:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x24
; GFX9-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0x34
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_mov_b32 s10, s2
; GFX9-NEXT:    s_mov_b32 s11, s3
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s12, s6
; GFX9-NEXT:    s_mov_b32 s13, s7
; GFX9-NEXT:    s_mov_b32 s14, s2
; GFX9-NEXT:    s_mov_b32 s15, s3
; GFX9-NEXT:    buffer_load_dwordx4 v[0:3], off, s[8:11], 0
; GFX9-NEXT:    buffer_load_dwordx4 v[4:7], off, s[12:15], 0
; GFX9-NEXT:    s_mov_b32 s0, s4
; GFX9-NEXT:    s_mov_b32 s1, s5
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_add_u32_e32 v0, v4, v0
; GFX9-NEXT:    v_add_u32_e32 v1, v5, v1
; GFX9-NEXT:    v_add_u32_e32 v2, v6, v2
; GFX9-NEXT:    v_add_u32_e32 v3, v7, v3
; GFX9-NEXT:    v_bfe_i32 v3, v3, 0, 16
; GFX9-NEXT:    v_bfe_i32 v2, v2, 0, 16
; GFX9-NEXT:    v_bfe_i32 v1, v1, 0, 16
; GFX9-NEXT:    v_bfe_i32 v0, v0, 0, 16
; GFX9-NEXT:    buffer_store_dwordx4 v[0:3], off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: vgpr_sext_in_reg_v4i16_to_v4i32:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 1, @10, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 1 @6
; EG-NEXT:    ALU 12, @12, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XYZW, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_128 T1.XYZW, T1.X, 0, #1
; EG-NEXT:     VTX_READ_128 T0.XYZW, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 10:
; EG-NEXT:     MOV T0.X, KC0[2].Z,
; EG-NEXT:     MOV * T1.X, KC0[2].W,
; EG-NEXT:    ALU clause starting at 12:
; EG-NEXT:     ADD_INT * T0.W, T0.W, T1.W,
; EG-NEXT:     BFE_INT T0.W, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T1.W, T0.Z, T1.Z,
; EG-NEXT:    16(2.242078e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.Z, PS, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T1.W, T0.Y, T1.Y,
; EG-NEXT:    16(2.242078e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.Y, PV.W, 0.0, literal.x,
; EG-NEXT:     ADD_INT * T1.W, T0.X, T1.X,
; EG-NEXT:    16(2.242078e-44), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T0.X, PV.W, 0.0, literal.x,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.y,
; EG-NEXT:    16(2.242078e-44), 2(2.802597e-45)
  %loada = load <4 x i32>, ptr addrspace(1) %a, align 16
  %loadb = load <4 x i32>, ptr addrspace(1) %b, align 16
  %c = add <4 x i32> %loada, %loadb ; add to prevent folding into extload
  %shl = shl <4 x i32> %c, <i32 16, i32 16, i32 16, i32 16>
  %ashr = ashr <4 x i32> %shl, <i32 16, i32 16, i32 16, i32 16>
  store <4 x i32> %ashr, ptr addrspace(1) %out, align 8
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_to_illegal_type:
; GCN: buffer_load_sbyte
; GCN: v_max_i32
; GCN-NOT: bfe
; GCN: buffer_store_short
define amdgpu_kernel void @sext_in_reg_to_illegal_type(ptr addrspace(1) nocapture %out, ptr addrspace(1) nocapture %src) #0 {
; SI-LABEL: sext_in_reg_to_illegal_type:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    s_mov_b32 s10, s6
; SI-NEXT:    s_mov_b32 s11, s7
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b32 s8, s2
; SI-NEXT:    s_mov_b32 s9, s3
; SI-NEXT:    buffer_load_sbyte v0, off, s[8:11], 0
; SI-NEXT:    s_mov_b32 s4, s0
; SI-NEXT:    s_mov_b32 s5, s1
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_max_i32_e32 v0, 0, v0
; SI-NEXT:    buffer_store_short v0, off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX89-LABEL: sext_in_reg_to_illegal_type:
; GFX89:       ; %bb.0:
; GFX89-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX89-NEXT:    s_mov_b32 s7, 0xf000
; GFX89-NEXT:    s_mov_b32 s6, -1
; GFX89-NEXT:    s_mov_b32 s10, s6
; GFX89-NEXT:    s_mov_b32 s11, s7
; GFX89-NEXT:    s_waitcnt lgkmcnt(0)
; GFX89-NEXT:    s_mov_b32 s8, s2
; GFX89-NEXT:    s_mov_b32 s9, s3
; GFX89-NEXT:    buffer_load_sbyte v0, off, s[8:11], 0
; GFX89-NEXT:    s_mov_b32 s4, s0
; GFX89-NEXT:    s_mov_b32 s5, s1
; GFX89-NEXT:    s_waitcnt vmcnt(0)
; GFX89-NEXT:    v_max_i32_e32 v0, 0, v0
; GFX89-NEXT:    buffer_store_short v0, off, s[4:7], 0
; GFX89-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_to_illegal_type:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_mov_b32 s10, s6
; GFX9-NEXT:    s_mov_b32 s11, s7
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_mov_b32 s8, s2
; GFX9-NEXT:    s_mov_b32 s9, s3
; GFX9-NEXT:    buffer_load_sbyte v0, off, s[8:11], 0
; GFX9-NEXT:    s_mov_b32 s4, s0
; GFX9-NEXT:    s_mov_b32 s5, s1
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_max_i32_e32 v0, 0, v0
; GFX9-NEXT:    buffer_store_short v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_to_illegal_type:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 12, @9, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT MSKOR T0.XW, T1.X
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_8 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     MOV * T0.X, KC0[2].Z,
; EG-NEXT:    ALU clause starting at 9:
; EG-NEXT:     BFE_INT T0.W, T0.X, 0.0, literal.x,
; EG-NEXT:     AND_INT * T1.W, KC0[2].Y, literal.y,
; EG-NEXT:    8(1.121039e-44), 3(4.203895e-45)
; EG-NEXT:     MAX_INT T0.W, PV.W, 0.0,
; EG-NEXT:     LSHL * T1.W, PS, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     LSHL T0.X, PV.W, PS,
; EG-NEXT:     LSHL * T0.W, literal.x, PS,
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     MOV * T0.Z, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %tmp5 = load i8, ptr addrspace(1) %src, align 1
  %tmp2 = sext i8 %tmp5 to i32
  %tmp2.5 = icmp sgt i32 %tmp2, 0
  %tmp3 = select i1 %tmp2.5, i32 %tmp2, i32 0
  %tmp4 = trunc i32 %tmp3 to i8
  %tmp6 = sext i8 %tmp4 to i16
  store i16 %tmp6, ptr addrspace(1) %out, align 2
  ret void
}

; Make sure we propagate the VALUness to users of a moved scalar BFE.

; FUNC-LABEL: {{^}}v_sext_in_reg_i1_to_i64_move_use:
; SI: buffer_load_dwordx2
; SI: v_lshl_b64 v[[[VAL_LO:[0-9]+]]:[[VAL_HI:[0-9]+]]]

; GFX89: {{flat|global}}_load_dwordx2
; GFX89: v_lshlrev_b64 v[[[VAL_LO:[0-9]+]]:[[VAL_HI:[0-9]+]]]

; GCN-DAG: v_bfe_i32 v[[LO:[0-9]+]], v[[VAL_LO]], 0, 1
; GCN-DAG: v_ashrrev_i32_e32 v[[HI:[0-9]+]], 31, v[[LO]]
; GCN-DAG: v_and_b32_e32 v[[RESULT_LO:[0-9]+]], s{{[0-9]+}}, v[[LO]]
; GCN-DAG: v_and_b32_e32 v[[RESULT_HI:[0-9]+]], s{{[0-9]+}}, v[[HI]]
; SI: buffer_store_dwordx2 v[[[RESULT_LO]]:[[RESULT_HI]]]
; GFX89: {{flat|global}}_store_dwordx2 v{{.+}}, v[[[RESULT_LO]]:[[RESULT_HI]]]
define amdgpu_kernel void @v_sext_in_reg_i1_to_i64_move_use(ptr addrspace(1) %out, ptr addrspace(1) %aptr, ptr addrspace(1) %bptr, i64 %s.val) #0 {
; SI-LABEL: v_sext_in_reg_i1_to_i64_move_use:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x9
; SI-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0xf
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_mov_b32 s2, 0
; SI-NEXT:    v_lshlrev_b32_e32 v0, 3, v0
; SI-NEXT:    v_mov_b32_e32 v1, 0
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b64 s[0:1], s[6:7]
; SI-NEXT:    buffer_load_dwordx2 v[2:3], v[0:1], s[0:3], 0 addr64
; SI-NEXT:    s_mov_b64 s[6:7], s[2:3]
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_lshl_b64 v[2:3], v[2:3], v2
; SI-NEXT:    v_bfe_i32 v2, v2, 0, 1
; SI-NEXT:    v_ashrrev_i32_e32 v3, 31, v2
; SI-NEXT:    v_and_b32_e32 v3, s9, v3
; SI-NEXT:    v_and_b32_e32 v2, s8, v2
; SI-NEXT:    buffer_store_dwordx2 v[2:3], v[0:1], s[4:7], 0 addr64
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: v_sext_in_reg_i1_to_i64_move_use:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x24
; GFX9-NEXT:    s_load_dwordx2 s[2:3], s[0:1], 0x3c
; GFX9-NEXT:    v_lshlrev_b32_e32 v2, 3, v0
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    global_load_dwordx2 v[0:1], v2, s[6:7]
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_lshlrev_b64 v[0:1], v0, v[0:1]
; GFX9-NEXT:    v_bfe_i32 v0, v0, 0, 1
; GFX9-NEXT:    v_ashrrev_i32_e32 v1, 31, v0
; GFX9-NEXT:    v_and_b32_e32 v1, s3, v1
; GFX9-NEXT:    v_and_b32_e32 v0, s2, v0
; GFX9-NEXT:    global_store_dwordx2 v2, v[0:1], s[4:5]
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: v_sext_in_reg_i1_to_i64_move_use:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 11, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT * T1.W, T0.X, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T1.W, T0.X, PV.W,
; EG-NEXT:     AND_INT * T2.W, T0.X, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT * T1.W, PS, PV.W, 0.0,
; EG-NEXT:     BFE_INT * T1.W, PV.W, 0.0, 1,
; EG-NEXT:     AND_INT * T0.Y, PV.W, KC0[3].Z,
; EG-NEXT:     AND_INT T0.X, T1.W, KC0[3].Y,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:     LSHR * T1.X, PV.W, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %a.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %b.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %out.gep = getelementptr i64, ptr addrspace(1) %out, i32 %tid
  %a = load i64, ptr addrspace(1) %a.gep, align 8
  %b = load i64, ptr addrspace(1) %b.gep, align 8

  %c = shl i64 %a, %b
  %shl = shl i64 %c, 63
  %ashr = ashr i64 %shl, 63

  %and = and i64 %ashr, %s.val
  store i64 %and, ptr addrspace(1) %out.gep, align 8
  ret void
}

; FUNC-LABEL: {{^}}v_sext_in_reg_i32_to_i64_move_use:
; SI: buffer_load_dwordx2
; SI: v_lshl_b64 v[[[LO:[0-9]+]]:[[HI:[0-9]+]]],

; GFX89: {{flat|global}}_load_dwordx2
; GFX89: v_lshlrev_b64 v[[[LO:[0-9]+]]:[[HI:[0-9]+]]],

; GCN-DAG: v_ashrrev_i32_e32 v[[SHR:[0-9]+]], 31, v[[LO]]
; GCN-DAG: v_and_b32_e32 v[[RESULT_LO:[0-9]+]], s{{[0-9]+}}, v[[LO]]
; GCN-DAG: v_and_b32_e32 v[[RESULT_HI:[0-9]+]], s{{[0-9]+}}, v[[SHR]]

; SI: buffer_store_dwordx2 v[[[RESULT_LO]]:[[RESULT_HI]]]
; GFX89: {{flat|global}}_store_dwordx2 v{{.+}}, v[[[RESULT_LO]]:[[RESULT_HI]]]
define amdgpu_kernel void @v_sext_in_reg_i32_to_i64_move_use(ptr addrspace(1) %out, ptr addrspace(1) %aptr, ptr addrspace(1) %bptr, i64 %s.val) #0 {
; SI-LABEL: v_sext_in_reg_i32_to_i64_move_use:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x9
; SI-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0xf
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_mov_b32 s2, 0
; SI-NEXT:    v_lshlrev_b32_e32 v0, 3, v0
; SI-NEXT:    v_mov_b32_e32 v1, 0
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b64 s[0:1], s[6:7]
; SI-NEXT:    buffer_load_dwordx2 v[2:3], v[0:1], s[0:3], 0 addr64
; SI-NEXT:    s_mov_b64 s[6:7], s[2:3]
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_lshl_b64 v[2:3], v[2:3], v2
; SI-NEXT:    v_ashrrev_i32_e32 v3, 31, v2
; SI-NEXT:    v_and_b32_e32 v3, s9, v3
; SI-NEXT:    v_and_b32_e32 v2, s8, v2
; SI-NEXT:    buffer_store_dwordx2 v[2:3], v[0:1], s[4:7], 0 addr64
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: v_sext_in_reg_i32_to_i64_move_use:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x24
; GFX9-NEXT:    s_load_dwordx2 s[2:3], s[0:1], 0x3c
; GFX9-NEXT:    v_lshlrev_b32_e32 v2, 3, v0
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    global_load_dwordx2 v[0:1], v2, s[6:7]
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_lshlrev_b64 v[0:1], v0, v[0:1]
; GFX9-NEXT:    v_ashrrev_i32_e32 v1, 31, v0
; GFX9-NEXT:    v_and_b32_e32 v1, s3, v1
; GFX9-NEXT:    v_and_b32_e32 v0, s2, v0
; GFX9-NEXT:    global_store_dwordx2 v2, v[0:1], s[4:5]
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: v_sext_in_reg_i32_to_i64_move_use:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 2, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 12, @11, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T0.XY, T1.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     LSHL * T0.W, T0.X, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    ALU clause starting at 11:
; EG-NEXT:     AND_INT * T1.W, T0.X, literal.x,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T1.W, T0.X, PV.W,
; EG-NEXT:     AND_INT * T2.W, T0.X, literal.x,
; EG-NEXT:    32(4.484155e-44), 0(0.000000e+00)
; EG-NEXT:     CNDE_INT * T1.W, PS, PV.W, 0.0,
; EG-NEXT:     AND_INT T0.X, PV.W, KC0[3].Y,
; EG-NEXT:     ASHR T1.W, PV.W, literal.x,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:    31(4.344025e-44), 0(0.000000e+00)
; EG-NEXT:     LSHR T1.X, PS, literal.x,
; EG-NEXT:     AND_INT * T0.Y, PV.W, KC0[3].Z,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %a.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %b.gep = getelementptr i64, ptr addrspace(1) %aptr, i32 %tid
  %out.gep = getelementptr i64, ptr addrspace(1) %out, i32 %tid
  %a = load i64, ptr addrspace(1) %a.gep, align 8
  %b = load i64, ptr addrspace(1) %b.gep, align 8

  %c = shl i64 %a, %b
  %shl = shl i64 %c, 32
  %ashr = ashr i64 %shl, 32
  %and = and i64 %ashr, %s.val
  store i64 %and, ptr addrspace(1) %out.gep, align 8
  ret void
}

; FUNC-LABEL: {{^}}s_sext_in_reg_i1_i16:
; GCN: s_load_dword [[VAL:s[0-9]+]]

; SI: s_bfe_i32 [[BFE:s[0-9]+]], [[VAL]], 0x10000
; SI: v_mov_b32_e32 [[VBFE:v[0-9]+]], [[BFE]]
; SI: buffer_store_short [[VBFE]]

; GFX89: s_lshl_b32 s{{[0-9]+}}, s{{[0-9]+}}, 15
; GFX89: s_sext_i32_i16 s{{[0-9]+}}, s{{[0-9]+}}
; GFX89: s_lshr_b32 s{{[0-9]+}}, s{{[0-9]+}}, 15
define amdgpu_kernel void @s_sext_in_reg_i1_i16(ptr addrspace(1) %out, ptr addrspace(4) %ptr) #0 {
; SI-LABEL: s_sext_in_reg_i1_i16:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_load_dword s2, s[2:3], 0x0
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_bfe_i32 s4, s2, 0x10000
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_short v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX89-LABEL: s_sext_in_reg_i1_i16:
; GFX89:       ; %bb.0:
; GFX89-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX89-NEXT:    s_waitcnt lgkmcnt(0)
; GFX89-NEXT:    s_load_dword s4, s[2:3], 0x0
; GFX89-NEXT:    s_mov_b32 s3, 0xf000
; GFX89-NEXT:    s_mov_b32 s2, -1
; GFX89-NEXT:    s_waitcnt lgkmcnt(0)
; GFX89-NEXT:    s_lshl_b32 s4, s4, 15
; GFX89-NEXT:    s_sext_i32_i16 s4, s4
; GFX89-NEXT:    s_lshr_b32 s4, s4, 15
; GFX89-NEXT:    v_mov_b32_e32 v0, s4
; GFX89-NEXT:    buffer_store_short v0, off, s[0:3], 0
; GFX89-NEXT:    s_endpgm
;
; GFX9-LABEL: s_sext_in_reg_i1_i16:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_load_dword s4, s[2:3], 0x0
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_lshl_b32 s4, s4, 15
; GFX9-NEXT:    s_sext_i32_i16 s4, s4
; GFX9-NEXT:    s_lshr_b32 s4, s4, 15
; GFX9-NEXT:    v_mov_b32_e32 v0, s4
; GFX9-NEXT:    buffer_store_short v0, off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: s_sext_in_reg_i1_i16:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 12, @9, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT MSKOR T0.XW, T1.X
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     MOV * T0.X, KC0[2].Z,
; EG-NEXT:    ALU clause starting at 9:
; EG-NEXT:     BFE_INT T0.W, T0.X, 0.0, 1,
; EG-NEXT:     AND_INT * T1.W, KC0[2].Y, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.W, PV.W, literal.x,
; EG-NEXT:     LSHL * T1.W, PS, literal.y,
; EG-NEXT:    65535(9.183409e-41), 3(4.203895e-45)
; EG-NEXT:     LSHL T0.X, PV.W, PS,
; EG-NEXT:     LSHL * T0.W, literal.x, PS,
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     MOV * T0.Z, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %ld = load i32, ptr addrspace(4) %ptr
  %in = trunc i32 %ld to i16
  %shl = shl i16 %in, 15
  %sext = ashr i16 %shl, 15
  store i16 %sext, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}s_sext_in_reg_i2_i16:
; GCN: s_load_dword [[VAL:s[0-9]+]]

; SI: s_bfe_i32 [[BFE:s[0-9]+]], [[VAL]], 0x20000
; SI: v_mov_b32_e32 [[VBFE:v[0-9]+]], [[BFE]]
; SI: buffer_store_short [[VBFE]]

; GFX89: s_lshl_b32 s{{[0-9]+}}, s{{[0-9]+}}, 14
; GFX89: s_sext_i32_i16 s{{[0-9]+}}, s{{[0-9]+}}
; GFX89: s_lshr_b32 s{{[0-9]+}}, s{{[0-9]+}}, 14
define amdgpu_kernel void @s_sext_in_reg_i2_i16(ptr addrspace(1) %out, ptr addrspace(4) %ptr) #0 {
; SI-LABEL: s_sext_in_reg_i2_i16:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_load_dword s2, s[2:3], 0x0
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_bfe_i32 s4, s2, 0x20000
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_short v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX89-LABEL: s_sext_in_reg_i2_i16:
; GFX89:       ; %bb.0:
; GFX89-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX89-NEXT:    s_waitcnt lgkmcnt(0)
; GFX89-NEXT:    s_load_dword s4, s[2:3], 0x0
; GFX89-NEXT:    s_mov_b32 s3, 0xf000
; GFX89-NEXT:    s_mov_b32 s2, -1
; GFX89-NEXT:    s_waitcnt lgkmcnt(0)
; GFX89-NEXT:    s_lshl_b32 s4, s4, 14
; GFX89-NEXT:    s_sext_i32_i16 s4, s4
; GFX89-NEXT:    s_lshr_b32 s4, s4, 14
; GFX89-NEXT:    v_mov_b32_e32 v0, s4
; GFX89-NEXT:    buffer_store_short v0, off, s[0:3], 0
; GFX89-NEXT:    s_endpgm
;
; GFX9-LABEL: s_sext_in_reg_i2_i16:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_load_dword s4, s[2:3], 0x0
; GFX9-NEXT:    s_mov_b32 s3, 0xf000
; GFX9-NEXT:    s_mov_b32 s2, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_lshl_b32 s4, s4, 14
; GFX9-NEXT:    s_sext_i32_i16 s4, s4
; GFX9-NEXT:    s_lshr_b32 s4, s4, 14
; GFX9-NEXT:    v_mov_b32_e32 v0, s4
; GFX9-NEXT:    buffer_store_short v0, off, s[0:3], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: s_sext_in_reg_i2_i16:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @8, KC0[CB0:0-32], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 14, @9, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT MSKOR T0.XW, T1.X
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_32 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     MOV * T0.X, KC0[2].Z,
; EG-NEXT:    ALU clause starting at 9:
; EG-NEXT:     LSHL T0.W, T0.X, literal.x,
; EG-NEXT:     AND_INT * T1.W, KC0[2].Y, literal.y,
; EG-NEXT:    30(4.203895e-44), 3(4.203895e-45)
; EG-NEXT:     ASHR * T0.W, PV.W, literal.x,
; EG-NEXT:    30(4.203895e-44), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.W, PV.W, literal.x,
; EG-NEXT:     LSHL * T1.W, T1.W, literal.y,
; EG-NEXT:    65535(9.183409e-41), 3(4.203895e-45)
; EG-NEXT:     LSHL T0.X, PV.W, PS,
; EG-NEXT:     LSHL * T0.W, literal.x, PS,
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     MOV * T0.Z, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %ld = load i32, ptr addrspace(4) %ptr
  %in = trunc i32 %ld to i16
  %shl = shl i16 %in, 14
  %sext = ashr i16 %shl, 14
  store i16 %sext, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}v_sext_in_reg_i1_i16:
; GCN: {{buffer|flat|global}}_load_ushort [[VAL:v[0-9]+]]
; GCN: v_bfe_i32 [[BFE:v[0-9]+]], [[VAL]], 0, 1{{$}}

; GCN: ds_write_b16 v{{[0-9]+}}, [[BFE]]
define amdgpu_kernel void @v_sext_in_reg_i1_i16(ptr addrspace(3) %out, ptr addrspace(1) %ptr) #0 {
; SI-LABEL: v_sext_in_reg_i1_i16:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dword s4, s[0:1], 0x9
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0xb
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_mov_b32 s2, 0
; SI-NEXT:    v_lshlrev_b32_e32 v0, 1, v0
; SI-NEXT:    v_mov_b32_e32 v1, 0
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    buffer_load_ushort v1, v[0:1], s[0:3], 0 addr64
; SI-NEXT:    v_add_i32_e32 v0, vcc, s4, v0
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_bfe_i32 v1, v1, 0, 1
; SI-NEXT:    s_mov_b32 m0, -1
; SI-NEXT:    ds_write_b16 v0, v1
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: v_sext_in_reg_i1_i16:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx2 s[2:3], s[0:1], 0x2c
; GFX9-NEXT:    v_lshlrev_b32_e32 v0, 1, v0
; GFX9-NEXT:    s_load_dword s0, s[0:1], 0x24
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    global_load_ushort v1, v0, s[2:3]
; GFX9-NEXT:    v_add_u32_e32 v0, s0, v0
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_bfe_i32 v1, v1, 0, 1
; GFX9-NEXT:    ds_write_b16 v0, v1
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: v_sext_in_reg_i1_i16:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 1, @41, KC0[CB0:0-32], KC1[]
; EG-NEXT:     LSHL * T0.W, T0.X, 1,
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    TEX 0 @0
; EG-NEXT:     VTX_READ_16 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU 2, @42, KC0[CB0:0-32], KC1[]
; EG-NEXT:     BFE_INT T1.W, T0.X, 0.0, 1,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:     LDS_SHORT_WRITE * T0.W, T1.W,
; EG-NEXT:    RETURN
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %gep = getelementptr i16, ptr addrspace(1) %ptr, i32 %tid
  %out.gep = getelementptr i16, ptr addrspace(3) %out, i32 %tid

  %in = load i16, ptr addrspace(1) %gep
  %shl = shl i16 %in, 15
  %sext = ashr i16 %shl, 15
  store i16 %sext, ptr addrspace(3) %out.gep
  ret void
}

; FUNC-LABEL: {{^}}v_sext_in_reg_i1_i16_nonload:
; GCN: {{buffer|flat|global}}_load_ushort [[VAL0:v[0-9]+]]
; GCN: {{buffer|flat|global}}_load_ushort [[VAL1:v[0-9]+]]

; SI: v_lshlrev_b32_e32 [[REG:v[0-9]+]], [[VAL1]], [[VAL0]]
; GFX89: v_lshlrev_b16_e32 [[REG:v[0-9]+]], [[VAL1]], [[VAL0]]

; GCN: v_bfe_i32 [[BFE:v[0-9]+]], [[REG]], 0, 1{{$}}
; GCN: ds_write_b16 v{{[0-9]+}}, [[BFE]]
define amdgpu_kernel void @v_sext_in_reg_i1_i16_nonload(ptr addrspace(3) %out, ptr addrspace(1) %aptr, ptr addrspace(1) %bptr, i16 %s.val) nounwind {
; SI-LABEL: v_sext_in_reg_i1_i16_nonload:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dword s12, s[0:1], 0x9
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0xb
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_mov_b32 s6, 0
; SI-NEXT:    v_lshlrev_b32_e32 v0, 1, v0
; SI-NEXT:    v_mov_b32_e32 v1, 0
; SI-NEXT:    s_mov_b64 s[10:11], s[6:7]
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_mov_b64 s[4:5], s[0:1]
; SI-NEXT:    s_mov_b64 s[8:9], s[2:3]
; SI-NEXT:    buffer_load_ushort v2, v[0:1], s[4:7], 0 addr64 glc
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    buffer_load_ushort v1, v[0:1], s[8:11], 0 addr64 glc
; SI-NEXT:    s_waitcnt vmcnt(0)
; SI-NEXT:    v_add_i32_e32 v0, vcc, s12, v0
; SI-NEXT:    v_lshlrev_b32_e32 v1, v1, v2
; SI-NEXT:    v_bfe_i32 v1, v1, 0, 1
; SI-NEXT:    s_mov_b32 m0, -1
; SI-NEXT:    ds_write_b16 v0, v1
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: v_sext_in_reg_i1_i16_nonload:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x2c
; GFX9-NEXT:    v_lshlrev_b32_e32 v0, 1, v0
; GFX9-NEXT:    s_load_dword s0, s[0:1], 0x24
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    global_load_ushort v1, v0, s[4:5] glc
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    global_load_ushort v2, v0, s[6:7] glc
; GFX9-NEXT:    s_waitcnt vmcnt(0)
; GFX9-NEXT:    v_add_u32_e32 v0, s0, v0
; GFX9-NEXT:    v_lshlrev_b16_e32 v1, v2, v1
; GFX9-NEXT:    v_bfe_i32 v1, v1, 0, 1
; GFX9-NEXT:    ds_write_b16 v0, v1
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: v_sext_in_reg_i1_i16_nonload:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 1, @43, KC0[CB0:0-32], KC1[]
; EG-NEXT:     LSHL * T0.W, T0.X, 1,
; EG-NEXT:     ADD_INT * T0.X, KC0[2].Z, PV.W,
; EG-NEXT:    TEX 0 @0
; EG-NEXT:     VTX_READ_16 T0.X, T0.X, 0, #1
; EG-NEXT:    ALU 0, @44, KC0[CB0:0-32], KC1[]
; EG-NEXT:     ADD_INT * T1.X, KC0[2].W, T0.W,
; EG-NEXT:    TEX 0 @0
; EG-NEXT:     VTX_READ_16 T1.X, T1.X, 0, #1
; EG-NEXT:    ALU 5, @45, KC0[CB0:0-32], KC1[]
; EG-NEXT:     AND_INT * T1.W, T1.X, literal.x,
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     LSHL * T1.W, T0.X, PV.W,
; EG-NEXT:     BFE_INT T1.W, PV.W, 0.0, 1,
; EG-NEXT:     ADD_INT * T0.W, KC0[2].Y, T0.W,
; EG-NEXT:     LDS_SHORT_WRITE * T0.W, T1.W,
; EG-NEXT:    RETURN
  %tid = call i32 @llvm.amdgcn.workitem.id.x()
  %a.gep = getelementptr i16, ptr addrspace(1) %aptr, i32 %tid
  %b.gep = getelementptr i16, ptr addrspace(1) %bptr, i32 %tid
  %out.gep = getelementptr i16, ptr addrspace(3) %out, i32 %tid
  %a = load volatile i16, ptr addrspace(1) %a.gep, align 2
  %b = load volatile i16, ptr addrspace(1) %b.gep, align 2

  %c = shl i16 %a, %b
  %shl = shl i16 %c, 15
  %ashr = ashr i16 %shl, 15

  store i16 %ashr, ptr addrspace(3) %out.gep, align 2
  ret void
}

; FUNC-LABEL: {{^}}s_sext_in_reg_i2_i16_arg:
; GCN: s_load_dword [[VAL:s[0-9]+]]

; SI: s_bfe_i32 [[BFE:s[0-9]+]], [[VAL]], 0x20000
; SI: v_mov_b32_e32 [[VBFE:v[0-9]+]], [[BFE]]
; SI: buffer_store_short [[VBFE]]

; GFX89: s_lshl_b32 s{{[0-9]+}}, s{{[0-9]+}}, 14{{$}}
; GFX89: s_sext_i32_i16 s{{[0-9]+}}, s{{[0-9]+}}
; GFX89: s_lshr_b32 s{{[0-9]+}}, s{{[0-9]+}}, 14{{$}}
define amdgpu_kernel void @s_sext_in_reg_i2_i16_arg(ptr addrspace(1) %out, i16 %in) #0 {
; SI-LABEL: s_sext_in_reg_i2_i16_arg:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dword s2, s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_bfe_i32 s4, s2, 0x20000
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_short v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: s_sext_in_reg_i2_i16_arg:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dword s2, s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[4:5], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_lshl_b32 s0, s2, 14
; GFX9-NEXT:    s_sext_i32_i16 s0, s0
; GFX9-NEXT:    s_lshr_b32 s0, s0, 14
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_short v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: s_sext_in_reg_i2_i16_arg:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @8, KC0[], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 14, @9, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT MSKOR T0.XW, T1.X
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_16 T0.X, T0.X, 40, #3
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     MOV * T0.X, 0.0,
; EG-NEXT:    ALU clause starting at 9:
; EG-NEXT:     LSHL T0.W, T0.X, literal.x,
; EG-NEXT:     AND_INT * T1.W, KC0[2].Y, literal.y,
; EG-NEXT:    30(4.203895e-44), 3(4.203895e-45)
; EG-NEXT:     ASHR * T0.W, PV.W, literal.x,
; EG-NEXT:    30(4.203895e-44), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.W, PV.W, literal.x,
; EG-NEXT:     LSHL * T1.W, T1.W, literal.y,
; EG-NEXT:    65535(9.183409e-41), 3(4.203895e-45)
; EG-NEXT:     LSHL T0.X, PV.W, PS,
; EG-NEXT:     LSHL * T0.W, literal.x, PS,
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     MOV * T0.Z, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %shl = shl i16 %in, 14
  %sext = ashr i16 %shl, 14
  store i16 %sext, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}s_sext_in_reg_i8_i16_arg:
; GCN: s_load_dword [[VAL:s[0-9]+]]

; SI: s_sext_i32_i8 [[SSEXT:s[0-9]+]], [[VAL]]
; SI: v_mov_b32_e32 [[VSEXT:v[0-9]+]], [[SSEXT]]
; SI: buffer_store_short [[VSEXT]]

; GFX89: s_lshl_b32 s{{[0-9]+}}, s{{[0-9]+}}, 8{{$}}
; GFX89: s_sext_i32_i16 s{{[0-9]+}}, s{{[0-9]+}}
; GFX89: s_lshr_b32 s{{[0-9]+}}, s{{[0-9]+}}, 8{{$}}
define amdgpu_kernel void @s_sext_in_reg_i8_i16_arg(ptr addrspace(1) %out, i16 %in) #0 {
; SI-LABEL: s_sext_in_reg_i8_i16_arg:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dword s2, s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_sext_i32_i8 s4, s2
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_short v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: s_sext_in_reg_i8_i16_arg:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dword s2, s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[4:5], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_lshl_b32 s0, s2, 8
; GFX9-NEXT:    s_sext_i32_i16 s0, s0
; GFX9-NEXT:    s_lshr_b32 s0, s0, 8
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_short v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: s_sext_in_reg_i8_i16_arg:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @8, KC0[], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 12, @9, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT MSKOR T0.XW, T1.X
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_8 T0.X, T0.X, 40, #3
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     MOV * T0.X, 0.0,
; EG-NEXT:    ALU clause starting at 9:
; EG-NEXT:     BFE_INT T0.W, T0.X, 0.0, literal.x,
; EG-NEXT:     AND_INT * T1.W, KC0[2].Y, literal.y,
; EG-NEXT:    8(1.121039e-44), 3(4.203895e-45)
; EG-NEXT:     AND_INT T0.W, PV.W, literal.x,
; EG-NEXT:     LSHL * T1.W, PS, literal.y,
; EG-NEXT:    65535(9.183409e-41), 3(4.203895e-45)
; EG-NEXT:     LSHL T0.X, PV.W, PS,
; EG-NEXT:     LSHL * T0.W, literal.x, PS,
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     MOV * T0.Z, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %shl = shl i16 %in, 8
  %sext = ashr i16 %shl, 8
  store i16 %sext, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}s_sext_in_reg_i15_i16_arg:
; GCN: s_load_dword [[VAL:s[0-9]+]]

; SI: s_bfe_i32 [[BFE:s[0-9]+]], [[VAL]], 0xf0000
; SI: v_mov_b32_e32 [[VBFE:v[0-9]+]], [[BFE]]
; SI: buffer_store_short [[VBFE]]

; GFX89: s_lshl_b32 s{{[0-9]+}}, s{{[0-9]+}}, 1{{$}}
; GFX89: s_sext_i32_i16 s{{[0-9]+}}, s{{[0-9]+}}
; GFX89: s_lshr_b32 s{{[0-9]+}}, s{{[0-9]+}}, 1{{$}}
define amdgpu_kernel void @s_sext_in_reg_i15_i16_arg(ptr addrspace(1) %out, i16 %in) #0 {
; SI-LABEL: s_sext_in_reg_i15_i16_arg:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dword s2, s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_bfe_i32 s4, s2, 0xf0000
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_short v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: s_sext_in_reg_i15_i16_arg:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dword s2, s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[4:5], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    s_lshl_b32 s0, s2, 1
; GFX9-NEXT:    s_sext_i32_i16 s0, s0
; GFX9-NEXT:    s_lshr_b32 s0, s0, 1
; GFX9-NEXT:    v_mov_b32_e32 v0, s0
; GFX9-NEXT:    buffer_store_short v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: s_sext_in_reg_i15_i16_arg:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @8, KC0[], KC1[]
; EG-NEXT:    TEX 0 @6
; EG-NEXT:    ALU 14, @9, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT MSKOR T0.XW, T1.X
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_16 T0.X, T0.X, 40, #3
; EG-NEXT:    ALU clause starting at 8:
; EG-NEXT:     MOV * T0.X, 0.0,
; EG-NEXT:    ALU clause starting at 9:
; EG-NEXT:     LSHL T0.W, T0.X, literal.x,
; EG-NEXT:     AND_INT * T1.W, KC0[2].Y, literal.y,
; EG-NEXT:    17(2.382207e-44), 3(4.203895e-45)
; EG-NEXT:     ASHR * T0.W, PV.W, literal.x,
; EG-NEXT:    17(2.382207e-44), 0(0.000000e+00)
; EG-NEXT:     AND_INT T0.W, PV.W, literal.x,
; EG-NEXT:     LSHL * T1.W, T1.W, literal.y,
; EG-NEXT:    65535(9.183409e-41), 3(4.203895e-45)
; EG-NEXT:     LSHL T0.X, PV.W, PS,
; EG-NEXT:     LSHL * T0.W, literal.x, PS,
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     MOV T0.Y, 0.0,
; EG-NEXT:     MOV * T0.Z, 0.0,
; EG-NEXT:     LSHR * T1.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %shl = shl i16 %in, 1
  %sext = ashr i16 %shl, 1
  store i16 %sext, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v2i1_to_v2i16:
; GFX9: v_pk_add_u16 [[ADD:v[0-9]+]]
; GFX9: v_pk_lshlrev_b16 [[SHL:v[0-9]+]], 15, [[ADD]]
; GFX9: v_pk_ashrrev_i16 [[SRA:v[0-9]+]], 15, [[SHL]]
define amdgpu_kernel void @sext_in_reg_v2i1_to_v2i16(ptr addrspace(1) %out, <2 x i16> %a, <2 x i16> %b) #0 {
; SI-LABEL: sext_in_reg_v2i1_to_v2i16:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_lshr_b32 s4, s2, 16
; SI-NEXT:    s_lshr_b32 s5, s3, 16
; SI-NEXT:    s_add_i32 s2, s2, s3
; SI-NEXT:    s_add_i32 s4, s4, s5
; SI-NEXT:    s_bfe_i32 s2, s2, 0x10000
; SI-NEXT:    s_bfe_i32 s3, s4, 0x10000
; SI-NEXT:    s_and_b32 s2, s2, 0xffff
; SI-NEXT:    s_lshl_b32 s3, s3, 16
; SI-NEXT:    s_or_b32 s2, s2, s3
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    s_mov_b32 s4, s0
; SI-NEXT:    s_mov_b32 s5, s1
; SI-NEXT:    v_mov_b32_e32 v0, s2
; SI-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v2i1_to_v2i16:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    v_mov_b32_e32 v0, s3
; GFX9-NEXT:    v_pk_add_u16 v0, s2, v0
; GFX9-NEXT:    v_pk_lshlrev_b16 v0, 15, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    s_mov_b32 s4, s0
; GFX9-NEXT:    s_mov_b32 s5, s1
; GFX9-NEXT:    v_pk_ashrrev_i16 v0, 15, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v2i1_to_v2i16:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @14, KC0[], KC1[]
; EG-NEXT:    TEX 3 @6
; EG-NEXT:    ALU 9, @15, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T4.X, T5.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_16 T5.X, T4.X, 42, #3
; EG-NEXT:     VTX_READ_16 T6.X, T4.X, 46, #3
; EG-NEXT:     VTX_READ_16 T7.X, T4.X, 40, #3
; EG-NEXT:     VTX_READ_16 T4.X, T4.X, 44, #3
; EG-NEXT:    ALU clause starting at 14:
; EG-NEXT:     MOV * T4.X, 0.0,
; EG-NEXT:    ALU clause starting at 15:
; EG-NEXT:     ADD_INT * T0.W, T5.X, T6.X,
; EG-NEXT:     ADD_INT * T1.W, T7.X, T4.X,
; EG-NEXT:     BFE_INT T0.Z, PV.W, 0.0, 1,
; EG-NEXT:     BFE_INT * T0.W, T0.W, 0.0, 1,
; EG-NEXT:     AND_INT T0.W, PV.W, literal.x,
; EG-NEXT:     AND_INT * T1.W, PV.Z, literal.y,
; EG-NEXT:    -65536(nan), 65535(9.183409e-41)
; EG-NEXT:     OR_INT T4.X, PV.W, PS,
; EG-NEXT:     LSHR * T5.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %c = add <2 x i16> %a, %b ; add to prevent folding into extload
  %shl = shl <2 x i16> %c, <i16 15, i16 15>
  %ashr = ashr <2 x i16> %shl, <i16 15, i16 15>
  store <2 x i16> %ashr, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v3i1_to_v3i16:
; GFX9: v_pk_add_u16
; GFX9: v_pk_add_u16
; GFX9: v_pk_lshlrev_b16 v{{[0-9]+}}, 15, v{{[0-9]+}}
; GFX9: v_pk_lshlrev_b16 v{{[0-9]+}}, 15, v{{[0-9]+}}
; GFX9: v_pk_ashrrev_i16 v{{[0-9]+}}, 15, v{{[0-9]+}}
; GFX9: v_pk_ashrrev_i16 v{{[0-9]+}}, 15, v{{[0-9]+}}
define amdgpu_kernel void @sext_in_reg_v3i1_to_v3i16(ptr addrspace(1) %out, <3 x i16> %a, <3 x i16> %b) #0 {
; SI-LABEL: sext_in_reg_v3i1_to_v3i16:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_lshr_b32 s8, s4, 16
; SI-NEXT:    s_lshr_b32 s9, s6, 16
; SI-NEXT:    s_add_i32 s5, s5, s7
; SI-NEXT:    s_add_i32 s4, s4, s6
; SI-NEXT:    s_add_i32 s8, s8, s9
; SI-NEXT:    s_bfe_i32 s4, s4, 0x10000
; SI-NEXT:    s_bfe_i32 s5, s5, 0x10000
; SI-NEXT:    s_bfe_i32 s6, s8, 0x10000
; SI-NEXT:    s_and_b32 s4, s4, 0xffff
; SI-NEXT:    v_mov_b32_e32 v0, s5
; SI-NEXT:    s_lshl_b32 s5, s6, 16
; SI-NEXT:    s_or_b32 s4, s4, s5
; SI-NEXT:    buffer_store_short v0, off, s[0:3], 0 offset:4
; SI-NEXT:    s_waitcnt expcnt(0)
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_dword v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v3i1_to_v3i16:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s11, 0xf000
; GFX9-NEXT:    s_mov_b32 s10, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    v_mov_b32_e32 v0, s7
; GFX9-NEXT:    v_mov_b32_e32 v1, s6
; GFX9-NEXT:    v_pk_add_u16 v0, s5, v0
; GFX9-NEXT:    v_pk_add_u16 v1, s4, v1
; GFX9-NEXT:    v_pk_lshlrev_b16 v0, 15, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    v_pk_lshlrev_b16 v1, 15, v1 op_sel_hi:[0,1]
; GFX9-NEXT:    v_pk_ashrrev_i16 v0, 15, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    v_pk_ashrrev_i16 v1, 15, v1 op_sel_hi:[0,1]
; GFX9-NEXT:    buffer_store_short v0, off, s[8:11], 0 offset:4
; GFX9-NEXT:    buffer_store_dword v1, off, s[8:11], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v3i1_to_v3i16:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @18, KC0[], KC1[]
; EG-NEXT:    TEX 5 @6
; EG-NEXT:    ALU 25, @19, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T7.X, T8.X, 0
; EG-NEXT:    MEM_RAT MSKOR T5.XW, T6.X
; EG-NEXT:    CF_END
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_16 T6.X, T5.X, 44, #3
; EG-NEXT:     VTX_READ_16 T7.X, T5.X, 52, #3
; EG-NEXT:     VTX_READ_16 T8.X, T5.X, 46, #3
; EG-NEXT:     VTX_READ_16 T9.X, T5.X, 54, #3
; EG-NEXT:     VTX_READ_16 T10.X, T5.X, 48, #3
; EG-NEXT:     VTX_READ_16 T5.X, T5.X, 56, #3
; EG-NEXT:    ALU clause starting at 18:
; EG-NEXT:     MOV * T5.X, 0.0,
; EG-NEXT:    ALU clause starting at 19:
; EG-NEXT:     ADD_INT T0.W, KC0[2].Y, literal.x,
; EG-NEXT:     ADD_INT * T1.W, T10.X, T5.X,
; EG-NEXT:    4(5.605194e-45), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T1.W, PS, 0.0, 1,
; EG-NEXT:     AND_INT * T2.W, PV.W, literal.x,
; EG-NEXT:    3(4.203895e-45), 0(0.000000e+00)
; EG-NEXT:     AND_INT T1.W, PV.W, literal.x,
; EG-NEXT:     LSHL * T2.W, PS, literal.y,
; EG-NEXT:    65535(9.183409e-41), 3(4.203895e-45)
; EG-NEXT:     LSHL T5.X, PV.W, PS,
; EG-NEXT:     LSHL * T5.W, literal.x, PS,
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     MOV T5.Y, 0.0,
; EG-NEXT:     MOV T5.Z, 0.0,
; EG-NEXT:     ADD_INT * T1.W, T8.X, T9.X,
; EG-NEXT:     ADD_INT * T2.W, T6.X, T7.X,
; EG-NEXT:     BFE_INT T0.Z, PV.W, 0.0, 1,
; EG-NEXT:     BFE_INT * T1.W, T1.W, 0.0, 1,
; EG-NEXT:     LSHR T6.X, T0.W, literal.x,
; EG-NEXT:     AND_INT T0.W, PV.W, literal.y,
; EG-NEXT:     AND_INT * T1.W, PV.Z, literal.z,
; EG-NEXT:    2(2.802597e-45), -65536(nan)
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     OR_INT T7.X, PV.W, PS,
; EG-NEXT:     LSHR * T8.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %c = add <3 x i16> %a, %b ; add to prevent folding into extload
  %shl = shl <3 x i16> %c, <i16 15, i16 15, i16 15>
  %ashr = ashr <3 x i16> %shl, <i16 15, i16 15, i16 15>
  store <3 x i16> %ashr, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v2i2_to_v2i16:
; GFX9: v_pk_add_u16 [[ADD:v[0-9]+]]
; GFX9: v_pk_lshlrev_b16 [[SHL:v[0-9]+]], 14, [[ADD]]
; GFX9: v_pk_ashrrev_i16 [[SRA:v[0-9]+]], 14, [[SHL]]
define amdgpu_kernel void @sext_in_reg_v2i2_to_v2i16(ptr addrspace(1) %out, <2 x i16> %a, <2 x i16> %b) #0 {
; SI-LABEL: sext_in_reg_v2i2_to_v2i16:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_lshr_b32 s4, s2, 16
; SI-NEXT:    s_lshr_b32 s5, s3, 16
; SI-NEXT:    s_add_i32 s2, s2, s3
; SI-NEXT:    s_add_i32 s4, s4, s5
; SI-NEXT:    s_bfe_i32 s2, s2, 0x20000
; SI-NEXT:    s_bfe_i32 s3, s4, 0x20000
; SI-NEXT:    s_and_b32 s2, s2, 0xffff
; SI-NEXT:    s_lshl_b32 s3, s3, 16
; SI-NEXT:    s_or_b32 s2, s2, s3
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    s_mov_b32 s4, s0
; SI-NEXT:    s_mov_b32 s5, s1
; SI-NEXT:    v_mov_b32_e32 v0, s2
; SI-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v2i2_to_v2i16:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    v_mov_b32_e32 v0, s3
; GFX9-NEXT:    v_pk_add_u16 v0, s2, v0
; GFX9-NEXT:    v_pk_lshlrev_b16 v0, 14, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    s_mov_b32 s4, s0
; GFX9-NEXT:    s_mov_b32 s5, s1
; GFX9-NEXT:    v_pk_ashrrev_i16 v0, 14, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v2i2_to_v2i16:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @14, KC0[], KC1[]
; EG-NEXT:    TEX 3 @6
; EG-NEXT:    ALU 13, @15, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T4.X, T5.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_16 T5.X, T4.X, 40, #3
; EG-NEXT:     VTX_READ_16 T6.X, T4.X, 44, #3
; EG-NEXT:     VTX_READ_16 T7.X, T4.X, 42, #3
; EG-NEXT:     VTX_READ_16 T4.X, T4.X, 46, #3
; EG-NEXT:    ALU clause starting at 14:
; EG-NEXT:     MOV * T4.X, 0.0,
; EG-NEXT:    ALU clause starting at 15:
; EG-NEXT:     ADD_INT * T0.W, T5.X, T6.X,
; EG-NEXT:     ADD_INT * T1.W, T7.X, T4.X,
; EG-NEXT:     LSHL T1.W, PV.W, literal.x,
; EG-NEXT:     LSHL * T0.W, T0.W, literal.x,
; EG-NEXT:    30(4.203895e-44), 0(0.000000e+00)
; EG-NEXT:     ASHR T0.W, PS, literal.x,
; EG-NEXT:     ASHR * T1.W, PV.W, literal.x,
; EG-NEXT:    30(4.203895e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T1.W, PS, literal.x,
; EG-NEXT:     AND_INT * T0.W, PV.W, literal.y,
; EG-NEXT:    16(2.242078e-44), 65535(9.183409e-41)
; EG-NEXT:     OR_INT T4.X, PV.W, PS,
; EG-NEXT:     LSHR * T5.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %c = add <2 x i16> %a, %b ; add to prevent folding into extload
  %shl = shl <2 x i16> %c, <i16 14, i16 14>
  %ashr = ashr <2 x i16> %shl, <i16 14, i16 14>
  store <2 x i16> %ashr, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v2i8_to_v2i16:
; GFX9: v_pk_add_u16 [[ADD:v[0-9]+]]
; GFX9: v_pk_lshlrev_b16 [[SHL:v[0-9]+]], 8, [[ADD]]
; GFX9: v_pk_ashrrev_i16 [[SRA:v[0-9]+]], 8, [[SHL]]
define amdgpu_kernel void @sext_in_reg_v2i8_to_v2i16(ptr addrspace(1) %out, <2 x i16> %a, <2 x i16> %b) #0 {
; SI-LABEL: sext_in_reg_v2i8_to_v2i16:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s7, 0xf000
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_lshr_b32 s4, s2, 16
; SI-NEXT:    s_lshr_b32 s5, s3, 16
; SI-NEXT:    s_add_i32 s2, s2, s3
; SI-NEXT:    s_add_i32 s4, s4, s5
; SI-NEXT:    s_sext_i32_i8 s2, s2
; SI-NEXT:    s_sext_i32_i8 s3, s4
; SI-NEXT:    s_and_b32 s2, s2, 0xffff
; SI-NEXT:    s_lshl_b32 s3, s3, 16
; SI-NEXT:    s_or_b32 s2, s2, s3
; SI-NEXT:    s_mov_b32 s6, -1
; SI-NEXT:    s_mov_b32 s4, s0
; SI-NEXT:    s_mov_b32 s5, s1
; SI-NEXT:    v_mov_b32_e32 v0, s2
; SI-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v2i8_to_v2i16:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[0:3], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s7, 0xf000
; GFX9-NEXT:    s_mov_b32 s6, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    v_mov_b32_e32 v0, s3
; GFX9-NEXT:    v_pk_add_u16 v0, s2, v0
; GFX9-NEXT:    v_pk_lshlrev_b16 v0, 8, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    s_mov_b32 s4, s0
; GFX9-NEXT:    s_mov_b32 s5, s1
; GFX9-NEXT:    v_pk_ashrrev_i16 v0, 8, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    buffer_store_dword v0, off, s[4:7], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v2i8_to_v2i16:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @14, KC0[], KC1[]
; EG-NEXT:    TEX 3 @6
; EG-NEXT:    ALU 10, @15, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T4.X, T5.X, 1
; EG-NEXT:    CF_END
; EG-NEXT:    PAD
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_16 T5.X, T4.X, 42, #3
; EG-NEXT:     VTX_READ_16 T6.X, T4.X, 46, #3
; EG-NEXT:     VTX_READ_16 T7.X, T4.X, 40, #3
; EG-NEXT:     VTX_READ_16 T4.X, T4.X, 44, #3
; EG-NEXT:    ALU clause starting at 14:
; EG-NEXT:     MOV * T4.X, 0.0,
; EG-NEXT:    ALU clause starting at 15:
; EG-NEXT:     ADD_INT * T0.W, T5.X, T6.X,
; EG-NEXT:     ADD_INT * T1.W, T7.X, T4.X,
; EG-NEXT:     BFE_INT T0.Z, PV.W, 0.0, literal.x,
; EG-NEXT:     BFE_INT * T0.W, T0.W, 0.0, literal.x,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     LSHL T0.W, PV.W, literal.x,
; EG-NEXT:     AND_INT * T1.W, PV.Z, literal.y,
; EG-NEXT:    16(2.242078e-44), 65535(9.183409e-41)
; EG-NEXT:     OR_INT T4.X, PV.W, PS,
; EG-NEXT:     LSHR * T5.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %c = add <2 x i16> %a, %b ; add to prevent folding into extload
  %shl = shl <2 x i16> %c, <i16 8, i16 8>
  %ashr = ashr <2 x i16> %shl, <i16 8, i16 8>
  store <2 x i16> %ashr, ptr addrspace(1) %out
  ret void
}

; FUNC-LABEL: {{^}}sext_in_reg_v3i8_to_v3i16:
; GFX9: v_pk_add_u16
; GFX9: v_pk_add_u16
; GFX9: v_pk_lshlrev_b16 v{{[0-9]+}}, 8, v{{[0-9]+}}
; GFX9: v_pk_lshlrev_b16 v{{[0-9]+}}, 8, v{{[0-9]+}}
; GFX9: v_pk_ashrrev_i16 v{{[0-9]+}}, 8, v{{[0-9]+}}
; GFX9: v_pk_ashrrev_i16 v{{[0-9]+}}, 8, v{{[0-9]+}}
define amdgpu_kernel void @sext_in_reg_v3i8_to_v3i16(ptr addrspace(1) %out, <3 x i16> %a, <3 x i16> %b) #0 {
; SI-LABEL: sext_in_reg_v3i8_to_v3i16:
; SI:       ; %bb.0:
; SI-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0xb
; SI-NEXT:    s_load_dwordx2 s[0:1], s[0:1], 0x9
; SI-NEXT:    s_mov_b32 s3, 0xf000
; SI-NEXT:    s_mov_b32 s2, -1
; SI-NEXT:    s_waitcnt lgkmcnt(0)
; SI-NEXT:    s_lshr_b32 s8, s4, 16
; SI-NEXT:    s_lshr_b32 s9, s6, 16
; SI-NEXT:    s_add_i32 s5, s5, s7
; SI-NEXT:    s_add_i32 s4, s4, s6
; SI-NEXT:    s_add_i32 s8, s8, s9
; SI-NEXT:    s_sext_i32_i8 s4, s4
; SI-NEXT:    s_sext_i32_i8 s5, s5
; SI-NEXT:    s_sext_i32_i8 s6, s8
; SI-NEXT:    s_and_b32 s4, s4, 0xffff
; SI-NEXT:    v_mov_b32_e32 v0, s5
; SI-NEXT:    s_lshl_b32 s5, s6, 16
; SI-NEXT:    s_or_b32 s4, s4, s5
; SI-NEXT:    buffer_store_short v0, off, s[0:3], 0 offset:4
; SI-NEXT:    s_waitcnt expcnt(0)
; SI-NEXT:    v_mov_b32_e32 v0, s4
; SI-NEXT:    buffer_store_dword v0, off, s[0:3], 0
; SI-NEXT:    s_endpgm
;
; GFX9-LABEL: sext_in_reg_v3i8_to_v3i16:
; GFX9:       ; %bb.0:
; GFX9-NEXT:    s_load_dwordx4 s[4:7], s[0:1], 0x2c
; GFX9-NEXT:    s_load_dwordx2 s[8:9], s[0:1], 0x24
; GFX9-NEXT:    s_mov_b32 s11, 0xf000
; GFX9-NEXT:    s_mov_b32 s10, -1
; GFX9-NEXT:    s_waitcnt lgkmcnt(0)
; GFX9-NEXT:    v_mov_b32_e32 v0, s7
; GFX9-NEXT:    v_mov_b32_e32 v1, s6
; GFX9-NEXT:    v_pk_add_u16 v0, s5, v0
; GFX9-NEXT:    v_pk_add_u16 v1, s4, v1
; GFX9-NEXT:    v_pk_lshlrev_b16 v0, 8, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    v_pk_lshlrev_b16 v1, 8, v1 op_sel_hi:[0,1]
; GFX9-NEXT:    v_pk_ashrrev_i16 v0, 8, v0 op_sel_hi:[0,1]
; GFX9-NEXT:    v_pk_ashrrev_i16 v1, 8, v1 op_sel_hi:[0,1]
; GFX9-NEXT:    buffer_store_short v0, off, s[8:11], 0 offset:4
; GFX9-NEXT:    buffer_store_dword v1, off, s[8:11], 0
; GFX9-NEXT:    s_endpgm
;
; EG-LABEL: sext_in_reg_v3i8_to_v3i16:
; EG:       ; %bb.0:
; EG-NEXT:    ALU 0, @18, KC0[], KC1[]
; EG-NEXT:    TEX 5 @6
; EG-NEXT:    ALU 26, @19, KC0[CB0:0-32], KC1[]
; EG-NEXT:    MEM_RAT_CACHELESS STORE_RAW T7.X, T8.X, 0
; EG-NEXT:    MEM_RAT MSKOR T5.XW, T6.X
; EG-NEXT:    CF_END
; EG-NEXT:    Fetch clause starting at 6:
; EG-NEXT:     VTX_READ_16 T6.X, T5.X, 44, #3
; EG-NEXT:     VTX_READ_16 T7.X, T5.X, 52, #3
; EG-NEXT:     VTX_READ_16 T8.X, T5.X, 46, #3
; EG-NEXT:     VTX_READ_16 T9.X, T5.X, 54, #3
; EG-NEXT:     VTX_READ_16 T10.X, T5.X, 48, #3
; EG-NEXT:     VTX_READ_16 T5.X, T5.X, 56, #3
; EG-NEXT:    ALU clause starting at 18:
; EG-NEXT:     MOV * T5.X, 0.0,
; EG-NEXT:    ALU clause starting at 19:
; EG-NEXT:     ADD_INT T0.W, KC0[2].Y, literal.x,
; EG-NEXT:     ADD_INT * T1.W, T10.X, T5.X,
; EG-NEXT:    4(5.605194e-45), 0(0.000000e+00)
; EG-NEXT:     BFE_INT T1.W, PS, 0.0, literal.x,
; EG-NEXT:     AND_INT * T2.W, PV.W, literal.y,
; EG-NEXT:    8(1.121039e-44), 3(4.203895e-45)
; EG-NEXT:     AND_INT T1.W, PV.W, literal.x,
; EG-NEXT:     LSHL * T2.W, PS, literal.y,
; EG-NEXT:    65535(9.183409e-41), 3(4.203895e-45)
; EG-NEXT:     LSHL T5.X, PV.W, PS,
; EG-NEXT:     LSHL * T5.W, literal.x, PS,
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     MOV T5.Y, 0.0,
; EG-NEXT:     MOV T5.Z, 0.0,
; EG-NEXT:     ADD_INT * T1.W, T8.X, T9.X,
; EG-NEXT:     ADD_INT * T2.W, T6.X, T7.X,
; EG-NEXT:     BFE_INT T0.Z, PV.W, 0.0, literal.x,
; EG-NEXT:     BFE_INT * T1.W, T1.W, 0.0, literal.x,
; EG-NEXT:    8(1.121039e-44), 0(0.000000e+00)
; EG-NEXT:     LSHR T6.X, T0.W, literal.x,
; EG-NEXT:     LSHL T0.W, PV.W, literal.y,
; EG-NEXT:     AND_INT * T1.W, PV.Z, literal.z,
; EG-NEXT:    2(2.802597e-45), 16(2.242078e-44)
; EG-NEXT:    65535(9.183409e-41), 0(0.000000e+00)
; EG-NEXT:     OR_INT T7.X, PV.W, PS,
; EG-NEXT:     LSHR * T8.X, KC0[2].Y, literal.x,
; EG-NEXT:    2(2.802597e-45), 0(0.000000e+00)
  %c = add <3 x i16> %a, %b ; add to prevent folding into extload
  %shl = shl <3 x i16> %c, <i16 8, i16 8, i16 8>
  %ashr = ashr <3 x i16> %shl, <i16 8, i16 8, i16 8>
  store <3 x i16> %ashr, ptr addrspace(1) %out
  ret void
}

declare i32 @llvm.amdgcn.workitem.id.x() #1

attributes #0 = { nounwind }
attributes #1 = { nounwind readnone }
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; FUNC: {{.*}}
; GCN: {{.*}}
