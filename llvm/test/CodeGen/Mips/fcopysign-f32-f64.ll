; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc  < %s -verify-machineinstrs -march=mips64el -mcpu=mips4 \
; RUN:   -target-abi=n64 | FileCheck %s -check-prefixes=ALL,64
; RUN: llc  < %s -verify-machineinstrs -march=mips64el -mcpu=mips64 \
; RUN:   -target-abi=n64 | FileCheck %s -check-prefixes=ALL,64
; RUN: llc  < %s -verify-machineinstrs -march=mips64el -mcpu=mips64r2 \
; RUN:   -target-abi=n64 | FileCheck %s -check-prefixes=ALL,64R2

declare double @copysign(double, double) nounwind readnone

declare float @copysignf(float, float) nounwind readnone

define float @func2(float %d, double %f) nounwind readnone {
; 64-LABEL: func2:
; 64:       # %bb.0: # %entry
; 64-NEXT:    lui $1, %highest(.LCPI0_0)
; 64-NEXT:    daddiu $1, $1, %higher(.LCPI0_0)
; 64-NEXT:    dsll $1, $1, 16
; 64-NEXT:    daddiu $1, $1, %hi(.LCPI0_0)
; 64-NEXT:    dsll $1, $1, 16
; 64-NEXT:    lwc1 $f0, %lo(.LCPI0_0)($1)
; 64-NEXT:    add.s $f0, $f12, $f0
; 64-NEXT:    mfc1 $1, $f0
; 64-NEXT:    dmfc1 $2, $f13
; 64-NEXT:    lui $3, 32767
; 64-NEXT:    ori $3, $3, 65535
; 64-NEXT:    and $1, $1, $3
; 64-NEXT:    dsrl $2, $2, 63
; 64-NEXT:    sll $2, $2, 0
; 64-NEXT:    sll $2, $2, 31
; 64-NEXT:    or $1, $1, $2
; 64-NEXT:    jr $ra
; 64-NEXT:    mtc1 $1, $f0
;
; 64R2-LABEL: func2:
; 64R2:       # %bb.0: # %entry
; 64R2-NEXT:    lui $1, %highest(.LCPI0_0)
; 64R2-NEXT:    daddiu $1, $1, %higher(.LCPI0_0)
; 64R2-NEXT:    dsll $1, $1, 16
; 64R2-NEXT:    daddiu $1, $1, %hi(.LCPI0_0)
; 64R2-NEXT:    dsll $1, $1, 16
; 64R2-NEXT:    lwc1 $f0, %lo(.LCPI0_0)($1)
; 64R2-NEXT:    add.s $f0, $f12, $f0
; 64R2-NEXT:    mfc1 $1, $f0
; 64R2-NEXT:    dmfc1 $2, $f13
; 64R2-NEXT:    dextu $2, $2, 63, 1
; 64R2-NEXT:    sll $2, $2, 0
; 64R2-NEXT:    ins $1, $2, 31, 1
; 64R2-NEXT:    jr $ra
; 64R2-NEXT:    mtc1 $1, $f0
entry:



  %add = fadd float %d, 1.000000e+00
  %conv = fptrunc double %f to float
  %call = tail call float @copysignf(float %add, float %conv) nounwind readnone
  ret float %call
}

define double @func3(double %d, float %f) nounwind readnone {
; 64-LABEL: func3:
; 64:       # %bb.0: # %entry
; 64-NEXT:    lui $1, %highest(.LCPI1_0)
; 64-NEXT:    daddiu $1, $1, %higher(.LCPI1_0)
; 64-NEXT:    dsll $1, $1, 16
; 64-NEXT:    daddiu $1, $1, %hi(.LCPI1_0)
; 64-NEXT:    dsll $1, $1, 16
; 64-NEXT:    ldc1 $f0, %lo(.LCPI1_0)($1)
; 64-NEXT:    add.d $f0, $f12, $f0
; 64-NEXT:    mfc1 $1, $f13
; 64-NEXT:    daddiu $2, $zero, 1
; 64-NEXT:    dmfc1 $3, $f0
; 64-NEXT:    dsll $2, $2, 63
; 64-NEXT:    daddiu $2, $2, -1
; 64-NEXT:    and $2, $3, $2
; 64-NEXT:    srl $1, $1, 31
; 64-NEXT:    dsll $1, $1, 63
; 64-NEXT:    or $1, $2, $1
; 64-NEXT:    jr $ra
; 64-NEXT:    dmtc1 $1, $f0
;
; 64R2-LABEL: func3:
; 64R2:       # %bb.0: # %entry
; 64R2-NEXT:    lui $1, %highest(.LCPI1_0)
; 64R2-NEXT:    daddiu $1, $1, %higher(.LCPI1_0)
; 64R2-NEXT:    dsll $1, $1, 16
; 64R2-NEXT:    daddiu $1, $1, %hi(.LCPI1_0)
; 64R2-NEXT:    dsll $1, $1, 16
; 64R2-NEXT:    ldc1 $f0, %lo(.LCPI1_0)($1)
; 64R2-NEXT:    add.d $f0, $f12, $f0
; 64R2-NEXT:    dmfc1 $1, $f0
; 64R2-NEXT:    mfc1 $2, $f13
; 64R2-NEXT:    ext $2, $2, 31, 1
; 64R2-NEXT:    dext $2, $2, 0, 32
; 64R2-NEXT:    dinsu $1, $2, 63, 1
; 64R2-NEXT:    jr $ra
; 64R2-NEXT:    dmtc1 $1, $f0
entry:



  %add = fadd double %d, 1.000000e+00
  %conv = fpext float %f to double
  %call = tail call double @copysign(double %add, double %conv) nounwind readnone
  ret double %call
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; ALL: {{.*}}
