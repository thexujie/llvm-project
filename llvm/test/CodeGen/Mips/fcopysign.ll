; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc  < %s -verify-machineinstrs -march=mipsel -mcpu=mips32 \
; RUN:   | FileCheck %s -check-prefix=32
; RUN: llc  < %s -verify-machineinstrs -march=mipsel -mcpu=mips32r2 \
; RUN:   | FileCheck %s -check-prefix=32R2
; RUN: llc  < %s -verify-machineinstrs -march=mips64el -mcpu=mips4 -target-abi=n64 \
; RUN:   | FileCheck %s -check-prefix=64
; RUN: llc  < %s -verify-machineinstrs -march=mips64el -mcpu=mips64 -target-abi=n64 \
; RUN:   | FileCheck %s -check-prefix=64
; RUN: llc  < %s -verify-machineinstrs -march=mips64el -mcpu=mips64r2 -target-abi=n64 \
; RUN:   | FileCheck %s -check-prefix=64R2

define double @func0(double %d0, double %d1) nounwind readnone {
; 32-LABEL: func0:
; 32:       # %bb.0: # %entry
; 32-NEXT:    mfc1 $1, $f15
; 32-NEXT:    lui $2, 32768
; 32-NEXT:    and $1, $1, $2
; 32-NEXT:    lui $2, 32767
; 32-NEXT:    ori $2, $2, 65535
; 32-NEXT:    mfc1 $3, $f13
; 32-NEXT:    and $2, $3, $2
; 32-NEXT:    or $1, $2, $1
; 32-NEXT:    mfc1 $2, $f12
; 32-NEXT:    mtc1 $2, $f0
; 32-NEXT:    jr $ra
; 32-NEXT:    mtc1 $1, $f1
;
; 32R2-LABEL: func0:
; 32R2:       # %bb.0: # %entry
; 32R2-NEXT:    mfhc1 $1, $f12
; 32R2-NEXT:    mfhc1 $2, $f14
; 32R2-NEXT:    ext $2, $2, 31, 1
; 32R2-NEXT:    ins $1, $2, 31, 1
; 32R2-NEXT:    mfc1 $2, $f12
; 32R2-NEXT:    mtc1 $2, $f0
; 32R2-NEXT:    mthc1 $1, $f0
; 32R2-NEXT:    jr $ra
; 32R2-NEXT:    nop
;
; 64-LABEL: func0:
; 64:       # %bb.0: # %entry
; 64-NEXT:    daddiu $1, $zero, 1
; 64-NEXT:    dsll $1, $1, 63
; 64-NEXT:    dmfc1 $2, $f13
; 64-NEXT:    and $2, $2, $1
; 64-NEXT:    dmfc1 $3, $f12
; 64-NEXT:    daddiu $1, $1, -1
; 64-NEXT:    and $1, $3, $1
; 64-NEXT:    or $1, $1, $2
; 64-NEXT:    jr $ra
; 64-NEXT:    dmtc1 $1, $f0
;
; 64R2-LABEL: func0:
; 64R2:       # %bb.0: # %entry
; 64R2-NEXT:    dmfc1 $1, $f12
; 64R2-NEXT:    dmfc1 $2, $f13
; 64R2-NEXT:    dextu $2, $2, 63, 1
; 64R2-NEXT:    dinsu $1, $2, 63, 1
; 64R2-NEXT:    jr $ra
; 64R2-NEXT:    dmtc1 $1, $f0
entry:




  %call = tail call double @copysign(double %d0, double %d1) nounwind readnone
  ret double %call
}

declare double @copysign(double, double) nounwind readnone

define float @func1(float %f0, float %f1) nounwind readnone {
; 32-LABEL: func1:
; 32:       # %bb.0: # %entry
; 32-NEXT:    mfc1 $1, $f14
; 32-NEXT:    lui $2, 32768
; 32-NEXT:    and $1, $1, $2
; 32-NEXT:    lui $2, 32767
; 32-NEXT:    ori $2, $2, 65535
; 32-NEXT:    mfc1 $3, $f12
; 32-NEXT:    and $2, $3, $2
; 32-NEXT:    or $1, $2, $1
; 32-NEXT:    jr $ra
; 32-NEXT:    mtc1 $1, $f0
;
; 32R2-LABEL: func1:
; 32R2:       # %bb.0: # %entry
; 32R2-NEXT:    mfc1 $1, $f12
; 32R2-NEXT:    mfc1 $2, $f14
; 32R2-NEXT:    ext $2, $2, 31, 1
; 32R2-NEXT:    ins $1, $2, 31, 1
; 32R2-NEXT:    jr $ra
; 32R2-NEXT:    mtc1 $1, $f0
;
; 64-LABEL: func1:
; 64:       # %bb.0: # %entry
; 64-NEXT:    mfc1 $1, $f13
; 64-NEXT:    lui $2, 32768
; 64-NEXT:    and $1, $1, $2
; 64-NEXT:    lui $2, 32767
; 64-NEXT:    ori $2, $2, 65535
; 64-NEXT:    mfc1 $3, $f12
; 64-NEXT:    and $2, $3, $2
; 64-NEXT:    or $1, $2, $1
; 64-NEXT:    jr $ra
; 64-NEXT:    mtc1 $1, $f0
;
; 64R2-LABEL: func1:
; 64R2:       # %bb.0: # %entry
; 64R2-NEXT:    mfc1 $1, $f12
; 64R2-NEXT:    mfc1 $2, $f13
; 64R2-NEXT:    ext $2, $2, 31, 1
; 64R2-NEXT:    ins $1, $2, 31, 1
; 64R2-NEXT:    jr $ra
; 64R2-NEXT:    mtc1 $1, $f0
entry:



  %call = tail call float @copysignf(float %f0, float %f1) nounwind readnone
  ret float %call
}

declare float @copysignf(float, float) nounwind readnone

