; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 4
; RUN: llc < %s -O0 -mtriple=i686-linux-gnu -global-isel=0 -verify-machineinstrs | FileCheck %s --check-prefix=DAG86
; RUN: llc < %s -O0 -mtriple=i686-linux-gnu -fast-isel -fast-isel-abort=1        | FileCheck %s --check-prefix=DAGF86
; RUN: llc < %s -O0 -mtriple=i686-linux-gnu -global-isel -global-isel-abort=1 -verify-machineinstrs | FileCheck %s --check-prefix=GISEL86
; RUN: llc < %s -O0 -mtriple=x86_64-linux-gnu -global-isel=0                     | FileCheck %s --check-prefix=DAG64
; RUN: llc < %s -O0 -mtriple=x86_64-linux-gnu -fast-isel -fast-isel-abort=1      | FileCheck %s --check-prefix=DAGF64
; RUN: llc < %s -O0 -mtriple=x86_64-linux-gnu -global-isel -global-isel-abort=1  | FileCheck %s --check-prefix=GISEL64

define i32 @brjt(i32 %num, i32 %x) {
; DAG86-LABEL: brjt:
; DAG86:       # %bb.0: # %entry
; DAG86-NEXT:    subl $8, %esp
; DAG86-NEXT:    .cfi_def_cfa_offset 12
; DAG86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; DAG86-NEXT:    movl %eax, (%esp) # 4-byte Spill
; DAG86-NEXT:    decl %eax
; DAG86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; DAG86-NEXT:    subl $3, %eax
; DAG86-NEXT:    ja .LBB0_4
; DAG86-NEXT:  # %bb.6: # %entry
; DAG86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Reload
; DAG86-NEXT:    movl .LJTI0_0(,%eax,4), %eax
; DAG86-NEXT:    jmpl *%eax
; DAG86-NEXT:  .LBB0_1: # %sw.bb
; DAG86-NEXT:    jmp .LBB0_5
; DAG86-NEXT:  .LBB0_2: # %sw.bb1
; DAG86-NEXT:    jmp .LBB0_5
; DAG86-NEXT:  .LBB0_3: # %sw.bb3
; DAG86-NEXT:    jmp .LBB0_5
; DAG86-NEXT:  .LBB0_4: # %sw.epilog
; DAG86-NEXT:    jmp .LBB0_5
; DAG86-NEXT:  .LBB0_5: # %return
; DAG86-NEXT:    movl (%esp), %eax # 4-byte Reload
; DAG86-NEXT:    addl $8, %esp
; DAG86-NEXT:    .cfi_def_cfa_offset 4
; DAG86-NEXT:    retl
;
; DAGF86-LABEL: brjt:
; DAGF86:       # %bb.0: # %entry
; DAGF86-NEXT:    subl $8, %esp
; DAGF86-NEXT:    .cfi_def_cfa_offset 12
; DAGF86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; DAGF86-NEXT:    movl %eax, (%esp) # 4-byte Spill
; DAGF86-NEXT:    decl %eax
; DAGF86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; DAGF86-NEXT:    subl $3, %eax
; DAGF86-NEXT:    ja .LBB0_4
; DAGF86-NEXT:  # %bb.6: # %entry
; DAGF86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %eax # 4-byte Reload
; DAGF86-NEXT:    movl .LJTI0_0(,%eax,4), %eax
; DAGF86-NEXT:    jmpl *%eax
; DAGF86-NEXT:  .LBB0_1: # %sw.bb
; DAGF86-NEXT:    jmp .LBB0_5
; DAGF86-NEXT:  .LBB0_2: # %sw.bb1
; DAGF86-NEXT:    jmp .LBB0_5
; DAGF86-NEXT:  .LBB0_3: # %sw.bb3
; DAGF86-NEXT:    jmp .LBB0_5
; DAGF86-NEXT:  .LBB0_4: # %sw.epilog
; DAGF86-NEXT:    jmp .LBB0_5
; DAGF86-NEXT:  .LBB0_5: # %return
; DAGF86-NEXT:    movl (%esp), %eax # 4-byte Reload
; DAGF86-NEXT:    addl $8, %esp
; DAGF86-NEXT:    .cfi_def_cfa_offset 4
; DAGF86-NEXT:    retl
;
; GISEL86-LABEL: brjt:
; GISEL86:       # %bb.1: # %entry
; GISEL86-NEXT:    subl $8, %esp
; GISEL86-NEXT:    .cfi_def_cfa_offset 12
; GISEL86-NEXT:    movl {{[0-9]+}}(%esp), %eax
; GISEL86-NEXT:    movl %eax, (%esp) # 4-byte Spill
; GISEL86-NEXT:    movl $3, %ecx
; GISEL86-NEXT:    subl $1, %eax
; GISEL86-NEXT:    movl %eax, {{[-0-9]+}}(%e{{[sb]}}p) # 4-byte Spill
; GISEL86-NEXT:    cmpl %ecx, %eax
; GISEL86-NEXT:    seta %al
; GISEL86-NEXT:    testb $1, %al
; GISEL86-NEXT:    jne .LBB0_5
; GISEL86-NEXT:  # %bb.7: # %entry
; GISEL86-NEXT:    movl {{[-0-9]+}}(%e{{[sb]}}p), %ecx # 4-byte Reload
; GISEL86-NEXT:    leal .LJTI0_0, %eax
; GISEL86-NEXT:    shll $2, %ecx
; GISEL86-NEXT:    leal (%eax,%ecx), %eax
; GISEL86-NEXT:    movl (%eax), %eax
; GISEL86-NEXT:    jmpl *%eax
; GISEL86-NEXT:  .LBB0_2: # %sw.bb
; GISEL86-NEXT:    jmp .LBB0_6
; GISEL86-NEXT:  .LBB0_3: # %sw.bb1
; GISEL86-NEXT:    jmp .LBB0_6
; GISEL86-NEXT:  .LBB0_4: # %sw.bb3
; GISEL86-NEXT:    jmp .LBB0_6
; GISEL86-NEXT:  .LBB0_5: # %sw.epilog
; GISEL86-NEXT:    jmp .LBB0_6
; GISEL86-NEXT:  .LBB0_6: # %return
; GISEL86-NEXT:    movl (%esp), %eax # 4-byte Reload
; GISEL86-NEXT:    addl $8, %esp
; GISEL86-NEXT:    .cfi_def_cfa_offset 4
; GISEL86-NEXT:    retl
;
; DAG64-LABEL: brjt:
; DAG64:       # %bb.0: # %entry
; DAG64-NEXT:    movl %edi, %eax
; DAG64-NEXT:    movl %eax, {{[-0-9]+}}(%r{{[sb]}}p) # 4-byte Spill
; DAG64-NEXT:    decl %eax
; DAG64-NEXT:    movl %eax, %ecx
; DAG64-NEXT:    movq %rcx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
; DAG64-NEXT:    subl $3, %eax
; DAG64-NEXT:    ja .LBB0_4
; DAG64-NEXT:  # %bb.6: # %entry
; DAG64-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rax # 8-byte Reload
; DAG64-NEXT:    movq .LJTI0_0(,%rax,8), %rax
; DAG64-NEXT:    jmpq *%rax
; DAG64-NEXT:  .LBB0_1: # %sw.bb
; DAG64-NEXT:    jmp .LBB0_5
; DAG64-NEXT:  .LBB0_2: # %sw.bb1
; DAG64-NEXT:    jmp .LBB0_5
; DAG64-NEXT:  .LBB0_3: # %sw.bb3
; DAG64-NEXT:    jmp .LBB0_5
; DAG64-NEXT:  .LBB0_4: # %sw.epilog
; DAG64-NEXT:    jmp .LBB0_5
; DAG64-NEXT:  .LBB0_5: # %return
; DAG64-NEXT:    movl {{[-0-9]+}}(%r{{[sb]}}p), %eax # 4-byte Reload
; DAG64-NEXT:    retq
;
; DAGF64-LABEL: brjt:
; DAGF64:       # %bb.0: # %entry
; DAGF64-NEXT:    movl %edi, %eax
; DAGF64-NEXT:    movl %eax, {{[-0-9]+}}(%r{{[sb]}}p) # 4-byte Spill
; DAGF64-NEXT:    decl %eax
; DAGF64-NEXT:    movl %eax, %ecx
; DAGF64-NEXT:    movq %rcx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
; DAGF64-NEXT:    subl $3, %eax
; DAGF64-NEXT:    ja .LBB0_4
; DAGF64-NEXT:  # %bb.6: # %entry
; DAGF64-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rax # 8-byte Reload
; DAGF64-NEXT:    movq .LJTI0_0(,%rax,8), %rax
; DAGF64-NEXT:    jmpq *%rax
; DAGF64-NEXT:  .LBB0_1: # %sw.bb
; DAGF64-NEXT:    jmp .LBB0_5
; DAGF64-NEXT:  .LBB0_2: # %sw.bb1
; DAGF64-NEXT:    jmp .LBB0_5
; DAGF64-NEXT:  .LBB0_3: # %sw.bb3
; DAGF64-NEXT:    jmp .LBB0_5
; DAGF64-NEXT:  .LBB0_4: # %sw.epilog
; DAGF64-NEXT:    jmp .LBB0_5
; DAGF64-NEXT:  .LBB0_5: # %return
; DAGF64-NEXT:    movl {{[-0-9]+}}(%r{{[sb]}}p), %eax # 4-byte Reload
; DAGF64-NEXT:    retq
;
; GISEL64-LABEL: brjt:
; GISEL64:       # %bb.1: # %entry
; GISEL64-NEXT:    movl %edi, {{[-0-9]+}}(%r{{[sb]}}p) # 4-byte Spill
; GISEL64-NEXT:    subl $1, %edi
; GISEL64-NEXT:    movl %edi, %eax
; GISEL64-NEXT:    # kill: def $rax killed $eax
; GISEL64-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
; GISEL64-NEXT:    movl $3, %ecx
; GISEL64-NEXT:    cmpq %rcx, %rax
; GISEL64-NEXT:    seta %al
; GISEL64-NEXT:    testb $1, %al
; GISEL64-NEXT:    jne .LBB0_5
; GISEL64-NEXT:  # %bb.7: # %entry
; GISEL64-NEXT:    movq {{[-0-9]+}}(%r{{[sb]}}p), %rcx # 8-byte Reload
; GISEL64-NEXT:    leaq .LJTI0_0, %rax
; GISEL64-NEXT:    shlq $3, %rcx
; GISEL64-NEXT:    leaq (%rax,%rcx), %rax
; GISEL64-NEXT:    movq (%rax), %rax
; GISEL64-NEXT:    jmpq *%rax
; GISEL64-NEXT:  .LBB0_2: # %sw.bb
; GISEL64-NEXT:    jmp .LBB0_6
; GISEL64-NEXT:  .LBB0_3: # %sw.bb1
; GISEL64-NEXT:    jmp .LBB0_6
; GISEL64-NEXT:  .LBB0_4: # %sw.bb3
; GISEL64-NEXT:    jmp .LBB0_6
; GISEL64-NEXT:  .LBB0_5: # %sw.epilog
; GISEL64-NEXT:    jmp .LBB0_6
; GISEL64-NEXT:  .LBB0_6: # %return
; GISEL64-NEXT:    movl {{[-0-9]+}}(%r{{[sb]}}p), %eax # 4-byte Reload
; GISEL64-NEXT:    retq
entry:
  switch i32 %num, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb1
    i32 3, label %return
    i32 4, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry
  br label %return

sw.bb1:                                           ; preds = %entry
  br label %return

sw.bb3:                                           ; preds = %entry
  br label %return

sw.epilog:                                        ; preds = %entry
  br label %return

return:                                           ; preds = %entry, %sw.epilog, %sw.bb3, %sw.bb1, %sw.bb
  ret i32 %num
}

!llvm.module.flags = !{!0}

!0 = !{i32 8, !"PIC Level", i32 2}
