# RUN: llc < %s -x mir -run-pass=codegenprepare | FileCheck %s --implicit-check-not="llvm.fake.use"
#
# When performing return duplication to enable
# tail call optimization we clone fake uses that exist in the to-be-eliminated
# return block into the predecessor blocks. When doing this with fake uses
# of PHI-nodes, they cannot be easily copied, but require the correct operand.
# We are currently not able to do this correctly, so we suppress the cloning
# of such fake uses at the moment.
#
# There should be no fake use of a call result in any of the resulting return
# blocks.


# CHECK: declare void @llvm.fake.use

# Fake uses of `this` should be duplicated into both return blocks.
# CHECK: if.then:
# CHECK: @llvm.fake.use({{.*}}this
# CHECK: if.else:
# CHECK: @llvm.fake.use({{.*}}this

--- |
  source_filename = "test.ll"

  %class.a = type { i8 }

  declare void @llvm.fake.use(...)
  declare i32 @foo(ptr nonnull dereferenceable(1)) local_unnamed_addr
  declare i32 @bar(ptr nonnull dereferenceable(1)) local_unnamed_addr

  define hidden void @func(ptr nonnull dereferenceable(1) %this) local_unnamed_addr align 2 {
  entry:
    %b = getelementptr inbounds %class.a, ptr %this, i64 0, i32 0
    %0 = load i8, i8* %b, align 1
    %tobool.not = icmp eq i8 %0, 0
    br i1 %tobool.not, label %if.else, label %if.then

  if.then:                                          ; preds = %entry
    %call = tail call i32 @foo(ptr nonnull dereferenceable(1) %this)
    %call2 = tail call i32 @bar(ptr nonnull dereferenceable(1) %this)
    br label %if.end

  if.else:                                          ; preds = %entry
    %call4 = tail call i32 @bar(ptr nonnull dereferenceable(1) %this)
    %call5 = tail call i32 @foo(ptr nonnull dereferenceable(1) %this)
    br label %if.end

  if.end:                                           ; preds = %if.else, %if.then
    %call4.sink = phi i32 [ %call4, %if.else ], [ %call, %if.then ]
    notail call void (...) @llvm.fake.use(i32 %call4.sink)
    notail call void (...) @llvm.fake.use(ptr nonnull %this)
    ret void
  }

...
---
name:            func
alignment:       16
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
registers:       []
liveins:         []
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        false
  stackProtector:  ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
debugValueSubstitutions: []
constants:       []
machineFunctionInfo: {}
body:             |

...
