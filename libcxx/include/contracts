// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_CONTRACTS
#define _LIBCPP_CONTRACTS

#include <__assertion_handler> // Note: this include is generated by CMake and is potentially vendor-provided.
#include <__config>
#include <source_location>
#include <version>

#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER
#  pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_STD
namespace contracts {

struct __private_constructor_tag {};

enum class assertion_kind { pre = 1, post = 2, assert = 3 };

enum class evaluation_semantic { enforce = 1, observe = 2, fast = 3 };

enum class detection_mode { predicate_false = 1, evaluation_exception = 2 };

class contract_violation {
public:
  _LIBCPP_HIDE_FROM_ABI constexpr explicit contract_violation(
      __private_constructor_tag,
      char const* __comment,
      enum detection_mode __mode,
      assertion_kind __kind,
      evaluation_semantic __semantic,
      source_location const& __location)
      : __comment_(__comment),
        __detection_mode_(__mode),
        __assertion_kind_(__kind),
        __location_(__location),
        __semantic_(__semantic) {}

  contract_violation(const contract_violation&)            = delete;
  contract_violation& operator=(const contract_violation&) = delete;

  ~contract_violation() = default;

  _LIBCPP_HIDE_FROM_ABI const char* comment() const noexcept;
  _LIBCPP_HIDE_FROM_ABI enum detection_mode detection_mode() const noexcept;
  _LIBCPP_HIDE_FROM_ABI assertion_kind kind() const noexcept;
  _LIBCPP_HIDE_FROM_ABI source_location location() const noexcept;
  _LIBCPP_HIDE_FROM_ABI evaluation_semantic semantic() const noexcept;

private:
  char const* __comment_;
  enum detection_mode __detection_mode_;
  assertion_kind __assertion_kind_;
  source_location __location_;
  evaluation_semantic __semantic_;
};

_LIBCPP_EXPORTED_FROM_ABI void __default_contract_violation_handler(contract_violation const&) noexcept;

_LIBCPP_HIDE_FROM_ABI inline void invoke_default_contract_violation_handler(contract_violation const& __cv) {
  contracts::__default_contract_violation_handler(__cv);
}

} // namespace contracts
_LIBCPP_END_NAMESPACE_STD

// Note that we could avoid declaring this function once we don't need to define the macros below.
_LIBCPP_OVERRIDABLE_FUNC_VIS void handle_contract_violation(const std::contracts::contract_violation&) noexcept
    /* strenghtened */;

_LIBCPP_BEGIN_NAMESPACE_STD
namespace contracts {

template <std::contracts::detection_mode _Mode,
          std::contracts::assertion_kind _Kind,
          std::contracts::evaluation_semantic _Semantic>
_LIBCPP_HIDE_FROM_ABI __attribute__((__cold__)) inline void
__handle_cv(char const* __message, std::source_location const& __location) {
  std::contracts::contract_violation __cv(
      ::std::contracts::__private_constructor_tag{}, __message, _Mode, _Kind, _Semantic, __location);

  ::handle_contract_violation(__cv);
}

} // namespace contracts
_LIBCPP_END_NAMESPACE_STD

#define _LIBCPP_TRAP(expr, message)                                                                                    \
  _LIBCPP_ASSERTION_HANDLER(                                                                                           \
      __FILE__ ":" _LIBCPP_TOSTRING(__LINE__) ": assertion " _LIBCPP_TOSTRING(expr) " failed: " message "\n")

#define _LIBCPP_ASSERT_IGNORE(expr, message, kind) /* nothing */

#define _LIBCPP_ASSERT_OBSERVE(expr, message, kind)                                                                    \
  do {                                                                                                                 \
    bool __violation;                                                                                                  \
    try {                                                                                                              \
      __violation = !__builtin_expect(static_cast<bool>(expr), 1);                                                     \
    } catch (...) {                                                                                                    \
      ::std::contracts::__handle_cv<::std::contracts::detection_mode::evaluation_exception,                            \
                                    kind,                                                                              \
                                    ::std::contracts::evaluation_semantic::observe>(                                   \
          message, ::std::source_location::current());                                                                 \
      _LIBCPP_TRAP(expr, message);                                                                                     \
    }                                                                                                                  \
    if (__violation) {                                                                                                 \
      ::std::contracts::__handle_cv<::std::contracts::detection_mode::predicate_false,                                 \
                                    kind,                                                                              \
                                    ::std::contracts::evaluation_semantic::observe>(                                   \
          message, ::std::source_location::current());                                                                 \
    }                                                                                                                  \
  } while (false)

#define _LIBCPP_ASSERT_ENFORCE(expr, message, kind)                                                                    \
  do {                                                                                                                 \
    bool __violation;                                                                                                  \
    try {                                                                                                              \
      __violation = !__builtin_expect(static_cast<bool>(expr), 1);                                                     \
    } catch (...) {                                                                                                    \
      ::std::contracts::__handle_cv<::std::contracts::detection_mode::evaluation_exception,                            \
                                    kind,                                                                              \
                                    ::std::contracts::evaluation_semantic::enforce>(                                   \
          message, ::std::source_location::current());                                                                 \
      _LIBCPP_TRAP(expr, message);                                                                                     \
    }                                                                                                                  \
    if (__violation) {                                                                                                 \
      ::std::contracts::__handle_cv<::std::contracts::detection_mode::predicate_false,                                 \
                                    kind,                                                                              \
                                    ::std::contracts::evaluation_semantic::enforce>(                                   \
          message, ::std::source_location::current());                                                                 \
      _LIBCPP_TRAP(expr, message);                                                                                     \
    }                                                                                                                  \
  } while (false)

#define _LIBCPP_ASSERT_ENFORCE_FAST(expr, message, kind)                                                               \
  (__builtin_expect(static_cast<bool>(expr), 1) ? (void)0 : _LIBCPP_TRAP(expr, message))

// Recommended practice: by default, enable the 'enforce' semantic.
#if !defined(_LIBCPP_CONTRACTS_EVALUATION_SEMANTIC_IGNORE) &&                                                          \
    !defined(_LIBCPP_CONTRACTS_EVALUATION_SEMANTIC_OBSERVE) &&                                                         \
    !defined(_LIBCPP_CONTRACTS_EVALUATION_SEMANTIC_ENFORCE) &&                                                         \
    !defined(_LIBCPP_CONTRACTS_EVALUATION_SEMANTIC_ENFORCE_FAST)
#  define _LIBCPP_CONTRACTS_EVALUATION_SEMANTIC_ENFORCE
#endif

// TODO: We should also take this in account for the ODR signature.
#if defined(_LIBCPP_CONTRACTS_EVALUATION_SEMANTIC_IGNORE)
#  define _LIBCPP_CONTRACT_ASSERT(expr, message, kind) _LIBCPP_ASSERT_IGNORE(expr, message, kind)
#elif defined(_LIBCPP_CONTRACTS_EVALUATION_SEMANTIC_OBSERVE)
#  define _LIBCPP_CONTRACT_ASSERT(expr, message, kind) _LIBCPP_ASSERT_OBSERVE(expr, message, kind)
#elif defined(_LIBCPP_CONTRACTS_EVALUATION_SEMANTIC_ENFORCE)
#  define _LIBCPP_CONTRACT_ASSERT(expr, message, kind) _LIBCPP_ASSERT_ENFORCE(expr, message, kind)
#elif defined(_LIBCPP_CONTRACTS_EVALUATION_SEMANTIC_ENFORCE_FAST)
#  define _LIBCPP_CONTRACT_ASSERT(expr, message, kind) _LIBCPP_ASSERT_ENFORCE_FAST(expr, message, kind)
#endif

#define __contract_assert__(expr, message)                                                                             \
  _LIBCPP_CONTRACT_ASSERT(expr, message, ::std::contracts::assertion_kind::assert)
#define __pre__(expr, message) _LIBCPP_CONTRACT_ASSERT(expr, message, ::std::contracts::assertion_kind::pre)
#define __post__(expr, message) _LIBCPP_CONTRACT_ASSERT(expr, message, ::std::contracts::assertion_kind::post)

#endif // _LIBCPP_CONTRACTS
