// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --include-generated-funcs --replace-value-regex "__omp_offloading_[0-9a-z]+_[0-9a-z]+" "reduction_size[.].+[.]" "pl_cond[.].+[.|,]" --prefix-filecheck-ir-name _ --version 4
// Only test codegen on target side, as private clause does not require any action on the host side
// Test target codegen - host bc file has to be created first.
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp -x c++ -triple powerpc64le-unknown-unknown -fopenmp-targets=powerpc64le-ibm-linux-gnu -emit-llvm-bc %s -o %t-ppc-host.bc
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp -x c++ -triple powerpc64le-unknown-unknown -fopenmp-targets=powerpc64le-ibm-linux-gnu -emit-llvm %s -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-ppc-host.bc -o - | FileCheck %s --check-prefix TCHECK --check-prefix TCHECK-64
// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -triple powerpc64le-unknown-unknown -fopenmp-targets=powerpc64le-ibm-linux-gnu -emit-pch -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-ppc-host.bc -o %t %s
// RUN: %clang_cc1 -fopenmp -x c++ -triple powerpc64le-unknown-unknown -fopenmp-targets=powerpc64le-ibm-linux-gnu -std=c++11 -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-ppc-host.bc -include-pch %t -verify -Wno-vla %s -emit-llvm -o - | FileCheck %s --check-prefix TCHECK --check-prefix TCHECK-64
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp -x c++ -triple i386-unknown-unknown -fopenmp-targets=i386-pc-linux-gnu -emit-llvm-bc %s -o %t-x86-host.bc
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp -x c++ -triple i386-unknown-unknown -fopenmp-targets=i386-pc-linux-gnu -emit-llvm %s -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-x86-host.bc -o - | FileCheck %s --check-prefix TCHECK --check-prefix TCHECK-32
// RUN: %clang_cc1 -fopenmp -x c++ -std=c++11 -triple i386-unknown-unknown -fopenmp-targets=i386-pc-linux-gnu -emit-pch -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-x86-host.bc -o %t %s
// RUN: %clang_cc1 -fopenmp -x c++ -triple i386-unknown-unknown -fopenmp-targets=i386-pc-linux-gnu -std=c++11 -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-x86-host.bc -include-pch %t -verify -Wno-vla %s -emit-llvm -o - | FileCheck %s --check-prefix TCHECK --check-prefix TCHECK-32

// RUN: %clang_cc1 -verify -Wno-vla -fopenmp-simd -x c++ -triple powerpc64le-unknown-unknown -fopenmp-targets=powerpc64le-ibm-linux-gnu -emit-llvm-bc %s -o %t-ppc-host.bc
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp-simd -x c++ -triple powerpc64le-unknown-unknown -fopenmp-targets=powerpc64le-ibm-linux-gnu -emit-llvm %s -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-ppc-host.bc -o - | FileCheck --check-prefix SIMD-ONLY0 %s
// RUN: %clang_cc1 -fopenmp-simd -x c++ -std=c++11 -triple powerpc64le-unknown-unknown -fopenmp-targets=powerpc64le-ibm-linux-gnu -emit-pch -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-ppc-host.bc -o %t %s
// RUN: %clang_cc1 -fopenmp-simd -x c++ -triple powerpc64le-unknown-unknown -fopenmp-targets=powerpc64le-ibm-linux-gnu -std=c++11 -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-ppc-host.bc -include-pch %t -verify -Wno-vla %s -emit-llvm -o - | FileCheck --check-prefix SIMD-ONLY0 %s
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp-simd -x c++ -triple i386-unknown-unknown -fopenmp-targets=i386-pc-linux-gnu -emit-llvm-bc %s -o %t-x86-host.bc
// RUN: %clang_cc1 -verify -Wno-vla -fopenmp-simd -x c++ -triple i386-unknown-unknown -fopenmp-targets=i386-pc-linux-gnu -emit-llvm %s -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-x86-host.bc -o - | FileCheck --check-prefix SIMD-ONLY0 %s
// RUN: %clang_cc1 -fopenmp-simd -x c++ -std=c++11 -triple i386-unknown-unknown -fopenmp-targets=i386-pc-linux-gnu -emit-pch -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-x86-host.bc -o %t %s
// RUN: %clang_cc1 -fopenmp-simd -x c++ -triple i386-unknown-unknown -fopenmp-targets=i386-pc-linux-gnu -std=c++11 -fopenmp-is-target-device -fopenmp-host-ir-file-path %t-x86-host.bc -include-pch %t -verify -Wno-vla %s -emit-llvm -o - | FileCheck --check-prefix SIMD-ONLY0 %s

// expected-no-diagnostics
#ifndef HEADER
#define HEADER

template<typename tx, typename ty>
struct TT{
  tx X;
  ty Y;
};


int foo(int n) {
  int a = 0;
  short aa = 0;
  float b[10];
  float bn[n];
  double c[5][10];
  double cn[5][n];
  TT<long long, char> d;

  #pragma omp target private(a)
  {
  }


#pragma omp target private(a)
  {
    a = 1;
  }


#pragma omp target private(a, aa)
  {
    a = 1;
    aa = 1;
  }


  #pragma omp target private(a, b, bn, c, cn, d)
  {
    a = 1;
    b[2] = 1.0;
    bn[3] = 1.0;
    c[1][2] = 1.0;
    cn[1][3] = 1.0;
    d.X = 1;
    d.Y = 1;
  }
  // make sure that private variables are generated in all cases and that we use those instances for operations inside the
  // target region

  // a = 1

  // b[2] = 1.0

  // bn[3] = 1.0

  // c[1][2] = 1.0

  // cn[1][3] = 1.0

  // d.X = 1
  // [[X_FIELD:%.+]] = getelementptr inbounds [[TT]] ptr [[D]], i{{[0-9]+}} 0, i{{[0-9]+}} 0
  // store i{{[0-9]+}} 1, ptr [[X_FIELD]],

  // d.Y = 1
  // [[Y_FIELD:%.+]] = getelementptr inbounds [[TT]] ptr [[D]], i{{[0-9]+}} 0, i{{[0-9]+}} 1
  // store i{{[0-9]+}} 1, ptr [[Y_FIELD]],

  // finish
  // [[RELOAD_SSTACK:%.+]] = load ptr, ptr [[SSTACK]],
  // call ovid @llvm.stackrestore.p0(ptr [[RELOAD_SSTACK]])
  // ret void

  return a;
}


template<typename tx>
tx ftemplate(int n) {
  tx a = 0;
  short aa = 0;
  tx b[10];

#pragma omp target private(a,aa,b)
  {
    a = 1;
    aa = 1;
    b[2] = 1;
  }

  return a;
}

static
int fstatic(int n) {
  int a = 0;
  short aa = 0;
  char aaa = 0;
  int b[10];

#pragma omp target private(a,aa,aaa,b)
  {
    a = 1;
    aa = 1;
    aaa = 1;
    b[2] = 1;
  }

  return a;
}


struct S1 {
  double a;

  int r1(int n){
    int b = n+1;
    short int c[2][n];

#pragma omp target private(b,c)
    {
      this->a = (double)b + 1.5;
      c[1][1] = ++a;
    }

    return c[1][1] + (int)b;
  }
};


int bar(int n){
  int a = 0;
  a += foo(n);
  S1 S;
  a += S.r1(n);
  a += fstatic(n);
  a += ftemplate<int>(n);

  return a;
}

// template

#endif
// TCHECK-64-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3fooi_l42(
// TCHECK-64-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0:[0-9]+]] {
// TCHECK-64-NEXT:  entry:
// TCHECK-64-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-64-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 8
// TCHECK-64-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    ret void
//
//
// TCHECK-64-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3fooi_l47(
// TCHECK-64-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-64-NEXT:  entry:
// TCHECK-64-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-64-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 8
// TCHECK-64-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-64-NEXT:    ret void
//
//
// TCHECK-64-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3fooi_l53(
// TCHECK-64-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-64-NEXT:  entry:
// TCHECK-64-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-64-NEXT:    [[AA:%.*]] = alloca i16, align 2
// TCHECK-64-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 8
// TCHECK-64-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-64-NEXT:    store i16 1, ptr [[AA]], align 2
// TCHECK-64-NEXT:    ret void
//
//
// TCHECK-64-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3fooi_l60(
// TCHECK-64-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-64-NEXT:  entry:
// TCHECK-64-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-64-NEXT:    [[B:%.*]] = alloca [10 x float], align 4
// TCHECK-64-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// TCHECK-64-NEXT:    [[C:%.*]] = alloca [5 x [10 x double]], align 8
// TCHECK-64-NEXT:    [[__VLA_EXPR1:%.*]] = alloca i64, align 8
// TCHECK-64-NEXT:    [[__VLA_EXPR2:%.*]] = alloca i64, align 8
// TCHECK-64-NEXT:    [[D:%.*]] = alloca [[STRUCT_TT:%.*]], align 8
// TCHECK-64-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 8
// TCHECK-64-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [[STRUCT_ANON_2:%.*]], ptr [[TMP0]], i32 0, i32 0
// TCHECK-64-NEXT:    [[TMP2:%.*]] = load i64, ptr [[TMP1]], align 8
// TCHECK-64-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[STRUCT_ANON_2]], ptr [[TMP0]], i32 0, i32 1
// TCHECK-64-NEXT:    [[TMP4:%.*]] = load i64, ptr [[TMP3]], align 8
// TCHECK-64-NEXT:    [[TMP5:%.*]] = getelementptr inbounds [[STRUCT_ANON_2]], ptr [[TMP0]], i32 0, i32 2
// TCHECK-64-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP5]], align 8
// TCHECK-64-NEXT:    [[TMP7:%.*]] = call ptr @llvm.stacksave.p0()
// TCHECK-64-NEXT:    store ptr [[TMP7]], ptr [[SAVED_STACK]], align 8
// TCHECK-64-NEXT:    [[VLA:%.*]] = alloca float, i64 [[TMP2]], align 4
// TCHECK-64-NEXT:    store i64 [[TMP2]], ptr [[__VLA_EXPR0]], align 8
// TCHECK-64-NEXT:    [[TMP8:%.*]] = mul nuw i64 [[TMP4]], [[TMP6]]
// TCHECK-64-NEXT:    [[VLA1:%.*]] = alloca double, i64 [[TMP8]], align 8
// TCHECK-64-NEXT:    store i64 [[TMP4]], ptr [[__VLA_EXPR1]], align 8
// TCHECK-64-NEXT:    store i64 [[TMP6]], ptr [[__VLA_EXPR2]], align 8
// TCHECK-64-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-64-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x float], ptr [[B]], i64 0, i64 2
// TCHECK-64-NEXT:    store float 1.000000e+00, ptr [[ARRAYIDX]], align 4
// TCHECK-64-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[VLA]], i64 3
// TCHECK-64-NEXT:    store float 1.000000e+00, ptr [[ARRAYIDX2]], align 4
// TCHECK-64-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds [5 x [10 x double]], ptr [[C]], i64 0, i64 1
// TCHECK-64-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [10 x double], ptr [[ARRAYIDX3]], i64 0, i64 2
// TCHECK-64-NEXT:    store double 1.000000e+00, ptr [[ARRAYIDX4]], align 8
// TCHECK-64-NEXT:    [[TMP9:%.*]] = mul nsw i64 1, [[TMP6]]
// TCHECK-64-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds double, ptr [[VLA1]], i64 [[TMP9]]
// TCHECK-64-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds double, ptr [[ARRAYIDX5]], i64 3
// TCHECK-64-NEXT:    store double 1.000000e+00, ptr [[ARRAYIDX6]], align 8
// TCHECK-64-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_TT]], ptr [[D]], i32 0, i32 0
// TCHECK-64-NEXT:    store i64 1, ptr [[X]], align 8
// TCHECK-64-NEXT:    [[Y:%.*]] = getelementptr inbounds [[STRUCT_TT]], ptr [[D]], i32 0, i32 1
// TCHECK-64-NEXT:    store i8 1, ptr [[Y]], align 8
// TCHECK-64-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8
// TCHECK-64-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP10]])
// TCHECK-64-NEXT:    ret void
//
//
// TCHECK-64-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__ZL7fstatici_l123(
// TCHECK-64-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-64-NEXT:  entry:
// TCHECK-64-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-64-NEXT:    [[AA:%.*]] = alloca i16, align 2
// TCHECK-64-NEXT:    [[AAA:%.*]] = alloca i8, align 1
// TCHECK-64-NEXT:    [[B:%.*]] = alloca [10 x i32], align 4
// TCHECK-64-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 8
// TCHECK-64-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-64-NEXT:    store i16 1, ptr [[AA]], align 2
// TCHECK-64-NEXT:    store i8 1, ptr [[AAA]], align 1
// TCHECK-64-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr [[B]], i64 0, i64 2
// TCHECK-64-NEXT:    store i32 1, ptr [[ARRAYIDX]], align 4
// TCHECK-64-NEXT:    ret void
//
//
// TCHECK-64-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__ZN2S12r1Ei_l142(
// TCHECK-64-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-64-NEXT:  entry:
// TCHECK-64-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[B:%.*]] = alloca i32, align 4
// TCHECK-64-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i64, align 8
// TCHECK-64-NEXT:    [[__VLA_EXPR1:%.*]] = alloca i64, align 8
// TCHECK-64-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 8
// TCHECK-64-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [[STRUCT_ANON_4:%.*]], ptr [[TMP0]], i32 0, i32 0
// TCHECK-64-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[TMP1]], align 8
// TCHECK-64-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[STRUCT_ANON_4]], ptr [[TMP0]], i32 0, i32 1
// TCHECK-64-NEXT:    [[TMP4:%.*]] = load i64, ptr [[TMP3]], align 8
// TCHECK-64-NEXT:    [[TMP5:%.*]] = getelementptr inbounds [[STRUCT_ANON_4]], ptr [[TMP0]], i32 0, i32 2
// TCHECK-64-NEXT:    [[TMP6:%.*]] = load i64, ptr [[TMP5]], align 8
// TCHECK-64-NEXT:    [[TMP7:%.*]] = call ptr @llvm.stacksave.p0()
// TCHECK-64-NEXT:    store ptr [[TMP7]], ptr [[SAVED_STACK]], align 8
// TCHECK-64-NEXT:    [[TMP8:%.*]] = mul nuw i64 [[TMP4]], [[TMP6]]
// TCHECK-64-NEXT:    [[VLA:%.*]] = alloca i16, i64 [[TMP8]], align 2
// TCHECK-64-NEXT:    store i64 [[TMP4]], ptr [[__VLA_EXPR0]], align 8
// TCHECK-64-NEXT:    store i64 [[TMP6]], ptr [[__VLA_EXPR1]], align 8
// TCHECK-64-NEXT:    [[TMP9:%.*]] = load i32, ptr [[B]], align 4
// TCHECK-64-NEXT:    [[CONV:%.*]] = sitofp i32 [[TMP9]] to double
// TCHECK-64-NEXT:    [[ADD:%.*]] = fadd double [[CONV]], 1.500000e+00
// TCHECK-64-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_S1:%.*]], ptr [[TMP2]], i32 0, i32 0
// TCHECK-64-NEXT:    store double [[ADD]], ptr [[A]], align 8
// TCHECK-64-NEXT:    [[A1:%.*]] = getelementptr inbounds [[STRUCT_S1]], ptr [[TMP2]], i32 0, i32 0
// TCHECK-64-NEXT:    [[TMP10:%.*]] = load double, ptr [[A1]], align 8
// TCHECK-64-NEXT:    [[INC:%.*]] = fadd double [[TMP10]], 1.000000e+00
// TCHECK-64-NEXT:    store double [[INC]], ptr [[A1]], align 8
// TCHECK-64-NEXT:    [[CONV2:%.*]] = fptosi double [[INC]] to i16
// TCHECK-64-NEXT:    [[TMP11:%.*]] = mul nsw i64 1, [[TMP6]]
// TCHECK-64-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i16, ptr [[VLA]], i64 [[TMP11]]
// TCHECK-64-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds i16, ptr [[ARRAYIDX]], i64 1
// TCHECK-64-NEXT:    store i16 [[CONV2]], ptr [[ARRAYIDX3]], align 2
// TCHECK-64-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[SAVED_STACK]], align 8
// TCHECK-64-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP12]])
// TCHECK-64-NEXT:    ret void
//
//
// TCHECK-64-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z9ftemplateIiET_i_l106(
// TCHECK-64-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-64-NEXT:  entry:
// TCHECK-64-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 8
// TCHECK-64-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-64-NEXT:    [[AA:%.*]] = alloca i16, align 2
// TCHECK-64-NEXT:    [[B:%.*]] = alloca [10 x i32], align 4
// TCHECK-64-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 8
// TCHECK-64-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 8
// TCHECK-64-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-64-NEXT:    store i16 1, ptr [[AA]], align 2
// TCHECK-64-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr [[B]], i64 0, i64 2
// TCHECK-64-NEXT:    store i32 1, ptr [[ARRAYIDX]], align 4
// TCHECK-64-NEXT:    ret void
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
// TCHECK-32-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3fooi_l42(
// TCHECK-32-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0:[0-9]+]] {
// TCHECK-32-NEXT:  entry:
// TCHECK-32-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 4
// TCHECK-32-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    ret void
//
//
// TCHECK-32-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3fooi_l47(
// TCHECK-32-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-32-NEXT:  entry:
// TCHECK-32-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 4
// TCHECK-32-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-32-NEXT:    ret void
//
//
// TCHECK-32-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3fooi_l53(
// TCHECK-32-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-32-NEXT:  entry:
// TCHECK-32-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    [[AA:%.*]] = alloca i16, align 2
// TCHECK-32-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 4
// TCHECK-32-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-32-NEXT:    store i16 1, ptr [[AA]], align 2
// TCHECK-32-NEXT:    ret void
//
//
// TCHECK-32-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z3fooi_l60(
// TCHECK-32-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-32-NEXT:  entry:
// TCHECK-32-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    [[B:%.*]] = alloca [10 x float], align 4
// TCHECK-32-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    [[C:%.*]] = alloca [5 x [10 x double]], align 8
// TCHECK-32-NEXT:    [[__VLA_EXPR1:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    [[__VLA_EXPR2:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    [[D:%.*]] = alloca [[STRUCT_TT:%.*]], align 4
// TCHECK-32-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 4
// TCHECK-32-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [[STRUCT_ANON_2:%.*]], ptr [[TMP0]], i32 0, i32 0
// TCHECK-32-NEXT:    [[TMP2:%.*]] = load i32, ptr [[TMP1]], align 4
// TCHECK-32-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[STRUCT_ANON_2]], ptr [[TMP0]], i32 0, i32 1
// TCHECK-32-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4
// TCHECK-32-NEXT:    [[TMP5:%.*]] = getelementptr inbounds [[STRUCT_ANON_2]], ptr [[TMP0]], i32 0, i32 2
// TCHECK-32-NEXT:    [[TMP6:%.*]] = load i32, ptr [[TMP5]], align 4
// TCHECK-32-NEXT:    [[TMP7:%.*]] = call ptr @llvm.stacksave.p0()
// TCHECK-32-NEXT:    store ptr [[TMP7]], ptr [[SAVED_STACK]], align 4
// TCHECK-32-NEXT:    [[VLA:%.*]] = alloca float, i32 [[TMP2]], align 4
// TCHECK-32-NEXT:    store i32 [[TMP2]], ptr [[__VLA_EXPR0]], align 4
// TCHECK-32-NEXT:    [[TMP8:%.*]] = mul nuw i32 [[TMP4]], [[TMP6]]
// TCHECK-32-NEXT:    [[VLA1:%.*]] = alloca double, i32 [[TMP8]], align 8
// TCHECK-32-NEXT:    store i32 [[TMP4]], ptr [[__VLA_EXPR1]], align 4
// TCHECK-32-NEXT:    store i32 [[TMP6]], ptr [[__VLA_EXPR2]], align 4
// TCHECK-32-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x float], ptr [[B]], i32 0, i32 2
// TCHECK-32-NEXT:    store float 1.000000e+00, ptr [[ARRAYIDX]], align 4
// TCHECK-32-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds float, ptr [[VLA]], i32 3
// TCHECK-32-NEXT:    store float 1.000000e+00, ptr [[ARRAYIDX2]], align 4
// TCHECK-32-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds [5 x [10 x double]], ptr [[C]], i32 0, i32 1
// TCHECK-32-NEXT:    [[ARRAYIDX4:%.*]] = getelementptr inbounds [10 x double], ptr [[ARRAYIDX3]], i32 0, i32 2
// TCHECK-32-NEXT:    store double 1.000000e+00, ptr [[ARRAYIDX4]], align 8
// TCHECK-32-NEXT:    [[TMP9:%.*]] = mul nsw i32 1, [[TMP6]]
// TCHECK-32-NEXT:    [[ARRAYIDX5:%.*]] = getelementptr inbounds double, ptr [[VLA1]], i32 [[TMP9]]
// TCHECK-32-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr inbounds double, ptr [[ARRAYIDX5]], i32 3
// TCHECK-32-NEXT:    store double 1.000000e+00, ptr [[ARRAYIDX6]], align 8
// TCHECK-32-NEXT:    [[X:%.*]] = getelementptr inbounds [[STRUCT_TT]], ptr [[D]], i32 0, i32 0
// TCHECK-32-NEXT:    store i64 1, ptr [[X]], align 4
// TCHECK-32-NEXT:    [[Y:%.*]] = getelementptr inbounds [[STRUCT_TT]], ptr [[D]], i32 0, i32 1
// TCHECK-32-NEXT:    store i8 1, ptr [[Y]], align 4
// TCHECK-32-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[SAVED_STACK]], align 4
// TCHECK-32-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP10]])
// TCHECK-32-NEXT:    ret void
//
//
// TCHECK-32-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__ZL7fstatici_l123(
// TCHECK-32-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-32-NEXT:  entry:
// TCHECK-32-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    [[AA:%.*]] = alloca i16, align 2
// TCHECK-32-NEXT:    [[AAA:%.*]] = alloca i8, align 1
// TCHECK-32-NEXT:    [[B:%.*]] = alloca [10 x i32], align 4
// TCHECK-32-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 4
// TCHECK-32-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-32-NEXT:    store i16 1, ptr [[AA]], align 2
// TCHECK-32-NEXT:    store i8 1, ptr [[AAA]], align 1
// TCHECK-32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr [[B]], i32 0, i32 2
// TCHECK-32-NEXT:    store i32 1, ptr [[ARRAYIDX]], align 4
// TCHECK-32-NEXT:    ret void
//
//
// TCHECK-32-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__ZN2S12r1Ei_l142(
// TCHECK-32-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-32-NEXT:  entry:
// TCHECK-32-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[B:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    [[SAVED_STACK:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[__VLA_EXPR0:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    [[__VLA_EXPR1:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 4
// TCHECK-32-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    [[TMP1:%.*]] = getelementptr inbounds [[STRUCT_ANON_4:%.*]], ptr [[TMP0]], i32 0, i32 0
// TCHECK-32-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[TMP1]], align 4
// TCHECK-32-NEXT:    [[TMP3:%.*]] = getelementptr inbounds [[STRUCT_ANON_4]], ptr [[TMP0]], i32 0, i32 1
// TCHECK-32-NEXT:    [[TMP4:%.*]] = load i32, ptr [[TMP3]], align 4
// TCHECK-32-NEXT:    [[TMP5:%.*]] = getelementptr inbounds [[STRUCT_ANON_4]], ptr [[TMP0]], i32 0, i32 2
// TCHECK-32-NEXT:    [[TMP6:%.*]] = load i32, ptr [[TMP5]], align 4
// TCHECK-32-NEXT:    [[TMP7:%.*]] = call ptr @llvm.stacksave.p0()
// TCHECK-32-NEXT:    store ptr [[TMP7]], ptr [[SAVED_STACK]], align 4
// TCHECK-32-NEXT:    [[TMP8:%.*]] = mul nuw i32 [[TMP4]], [[TMP6]]
// TCHECK-32-NEXT:    [[VLA:%.*]] = alloca i16, i32 [[TMP8]], align 2
// TCHECK-32-NEXT:    store i32 [[TMP4]], ptr [[__VLA_EXPR0]], align 4
// TCHECK-32-NEXT:    store i32 [[TMP6]], ptr [[__VLA_EXPR1]], align 4
// TCHECK-32-NEXT:    [[TMP9:%.*]] = load i32, ptr [[B]], align 4
// TCHECK-32-NEXT:    [[CONV:%.*]] = sitofp i32 [[TMP9]] to double
// TCHECK-32-NEXT:    [[ADD:%.*]] = fadd double [[CONV]], 1.500000e+00
// TCHECK-32-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_S1:%.*]], ptr [[TMP2]], i32 0, i32 0
// TCHECK-32-NEXT:    store double [[ADD]], ptr [[A]], align 4
// TCHECK-32-NEXT:    [[A1:%.*]] = getelementptr inbounds [[STRUCT_S1]], ptr [[TMP2]], i32 0, i32 0
// TCHECK-32-NEXT:    [[TMP10:%.*]] = load double, ptr [[A1]], align 4
// TCHECK-32-NEXT:    [[INC:%.*]] = fadd double [[TMP10]], 1.000000e+00
// TCHECK-32-NEXT:    store double [[INC]], ptr [[A1]], align 4
// TCHECK-32-NEXT:    [[CONV2:%.*]] = fptosi double [[INC]] to i16
// TCHECK-32-NEXT:    [[TMP11:%.*]] = mul nsw i32 1, [[TMP6]]
// TCHECK-32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i16, ptr [[VLA]], i32 [[TMP11]]
// TCHECK-32-NEXT:    [[ARRAYIDX3:%.*]] = getelementptr inbounds i16, ptr [[ARRAYIDX]], i32 1
// TCHECK-32-NEXT:    store i16 [[CONV2]], ptr [[ARRAYIDX3]], align 2
// TCHECK-32-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[SAVED_STACK]], align 4
// TCHECK-32-NEXT:    call void @llvm.stackrestore.p0(ptr [[TMP12]])
// TCHECK-32-NEXT:    ret void
//
//
// TCHECK-32-LABEL: define weak_odr protected void @{{__omp_offloading_[0-9a-z]+_[0-9a-z]+}}__Z9ftemplateIiET_i_l106(
// TCHECK-32-SAME: ptr noalias noundef [[DYN_PTR:%.*]], ptr noalias noundef [[__CONTEXT:%.*]]) #[[ATTR0]] {
// TCHECK-32-NEXT:  entry:
// TCHECK-32-NEXT:    [[DYN_PTR_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[__CONTEXT_ADDR:%.*]] = alloca ptr, align 4
// TCHECK-32-NEXT:    [[A:%.*]] = alloca i32, align 4
// TCHECK-32-NEXT:    [[AA:%.*]] = alloca i16, align 2
// TCHECK-32-NEXT:    [[B:%.*]] = alloca [10 x i32], align 4
// TCHECK-32-NEXT:    store ptr [[DYN_PTR]], ptr [[DYN_PTR_ADDR]], align 4
// TCHECK-32-NEXT:    store ptr [[__CONTEXT]], ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[__CONTEXT_ADDR]], align 4
// TCHECK-32-NEXT:    store i32 1, ptr [[A]], align 4
// TCHECK-32-NEXT:    store i16 1, ptr [[AA]], align 2
// TCHECK-32-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [10 x i32], ptr [[B]], i32 0, i32 2
// TCHECK-32-NEXT:    store i32 1, ptr [[ARRAYIDX]], align 4
// TCHECK-32-NEXT:    ret void

// NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
// SIMD-ONLY0: {{.*}}
// TCHECK: {{.*}}
